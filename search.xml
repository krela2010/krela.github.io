<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>提高开发效率的N种方法</title>
    <url>/2020/08/07/iOS/</url>
    <content><![CDATA[<p>介绍几种提高mac下开发效率的方法、包括Xcode快捷键、vi快捷键、Alfred工作流、宏</p>
<a id="more"></a> 
<h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><pre><code>ctrl+f                光标向前
ctrl+b                光标向后
ctrl+a                光标行头
ctrl+e                光标行尾
ctrl+shift+f          向前选中
ctrl+shift+b          向后选中
ctrl+shift+a          向前选中至行头
ctrl+shift+e          向后选中至行尾
ctrl+k                向后删除当前行
ctrl+6                搜索当前文件函数
ctril+shift+,         显示scheme配置（build、run等）
cmd+,                 配置工程
ctrl+cmd+up/down      头文件和实现文件切换
ctrl+cmd+left/right   文件历史栈切换</code></pre>
<h3 id="vi快捷键"><a href="#vi快捷键" class="headerlink" title="vi快捷键"></a>vi快捷键</h3><pre><code>shift zz 快速保存退出</code></pre>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>#<div class="video-container"><iframe src="https://www.youtube.com/embed/DBWu6TnhLeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>
]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记</title>
    <url>/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>持续更新中</p>
<a id="more"></a>
<h3 id="1-oc起源"><a href="#1-oc起源" class="headerlink" title="1.oc起源"></a>1.oc起源</h3><h3 id="2-减少头文件引用"><a href="#2-减少头文件引用" class="headerlink" title="2.减少头文件引用"></a>2.减少头文件引用</h3><ul>
<li>如果不使用类方法可以仅声明@class Class 即可</li>
</ul>
<h3 id="3-多用字面量"><a href="#3-多用字面量" class="headerlink" title="3.多用字面量"></a>3.多用字面量</h3><ul>
<li>代码整洁、直观</li>
<li>NSArray arrayWithObject：遇到nil不会崩溃，内部会判断</li>
</ul>
<h3 id="4-少用define"><a href="#4-少用define" class="headerlink" title="4.少用define"></a>4.少用define</h3><ul>
<li>建议使用const来替代：<ol>
<li>可以加static 控制作用域、避免冲突</li>
<li>类型含义明确，维护性好</li>
<li>static 编译器会自行优化为define</li>
</ol>
</li>
</ul>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><ul>
<li>占用1字节</li>
<li>type NS_ENUM oc枚举<ol>
<li>根据编译平台决定使用新、旧协议(c++)</li>
<li>新协议指的是底层数据类型存储</li>
<li>switch 处理enum分支；尽量不用default，覆盖每一个分支，避免新增enum，switch未处理的情况</li>
</ol>
</li>
</ul>
<h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><ul>
<li>类对象保管存储偏移量</li>
<li>@dynamic 配合CoreData动态添加方法</li>
</ul>
<h3 id="7-对象内部使用实例变量"><a href="#7-对象内部使用实例变量" class="headerlink" title="7.对象内部使用实例变量"></a>7.对象内部使用实例变量</h3><ul>
<li><p>self.var 语法</p>
<ol>
<li>效率低</li>
<li>可触发kvo，可使用懒加载</li>
</ol>
</li>
<li><p><code>_var</code> 语法</p>
<ol>
<li>不触发kvo</li>
<li>getter语法里使用</li>
</ol>
</li>
<li><p>折中方案</p>
<ol>
<li>写入用setter</li>
<li>读取用_var</li>
</ol>
</li>
</ul>
<h3 id="8-对象等同性"><a href="#8-对象等同性" class="headerlink" title="8.对象等同性"></a>8.对象等同性</h3><ul>
<li>isEqualToString比isEqual快</li>
<li>== 判断指针操作</li>
<li>hash()方法用于比较，自己实现；注意set时 的hash 碰撞问题</li>
<li>结构对象使用主键比较</li>
</ul>
<h3 id="9-类簇"><a href="#9-类簇" class="headerlink" title="9.类簇"></a>9.类簇</h3><ul>
<li>oc没有概念上的抽象类，oc的抽象类不写init</li>
<li>类簇类似抽象类的概念，提供接口，不提供实现</li>
<li>NSArray 里面是工厂，NSArray class 隐藏 无法通过实例访问<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[arr <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[str <span class="keyword">class</span>], [<span class="built_in">NSString</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">///分别打印</span></span><br><span class="line">__NSArray0|<span class="built_in">NSArray</span></span><br><span class="line">__NSCFConstantString|<span class="built_in">NSString</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-动态添加属性"><a href="#10-动态添加属性" class="headerlink" title="10.动态添加属性"></a>10.动态添加属性</h3><ul>
<li>本质是全局创建Map，以Class为key的外部表</li>
<li>示例：UIAlertView存在多个，通过此方法区分每个；不建议这么用；不好定位异常</li>
</ul>
<h3 id="11-消息派发"><a href="#11-消息派发" class="headerlink" title="11.消息派发"></a>11.消息派发</h3><ul>
<li>objc_msg_send 有两个隐藏参数 (id,SEL)</li>
<li>runtime</li>
<li>尾调用优化：去掉函数栈帧，优化</li>
</ul>
<h3 id="12-消息转发"><a href="#12-消息转发" class="headerlink" title="12.消息转发"></a>12.消息转发</h3><ul>
<li>resolveInstanceMethod/resolveClassMethod<ol>
<li>配合@dynamic</li>
</ol>
</li>
<li>备用接受者 forwardingTargetForSelector<ol>
<li>返回接收对象</li>
<li>1对1</li>
<li>快速</li>
</ol>
</li>
<li>完成消息转发forwardInvocation<ol>
<li>修改方法内容</li>
<li>1对多</li>
<li>慢</li>
</ol>
</li>
</ul>
<h3 id="13-方法交换"><a href="#13-方法交换" class="headerlink" title="13.方法交换"></a>13.方法交换</h3><ul>
<li>用于调试目的<ol>
<li>用户行为监控</li>
<li>调试异常</li>
<li>一般应用层不建议使用</li>
</ol>
</li>
</ul>
<h3 id="14-类对象意义"><a href="#14-类对象意义" class="headerlink" title="14.类对象意义"></a>14.类对象意义</h3><ul>
<li>判断对象关系 isKindOf isMemberOf；</li>
<li>示例：NSProxy 对于isKinfOf 对 class处理可能不一样(消息转发)</li>
<li>消息传递机制的前提</li>
</ul>
<h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul>
<li>c函数需要加前缀</li>
<li>lib对象，自己引用的第三方加前缀</li>
</ul>
<h3 id="16-全能初始化器"><a href="#16-全能初始化器" class="headerlink" title="16.全能初始化器"></a>16.全能初始化器</h3><ul>
<li><p>和swift的指定初始化器类似，swift 强制性 oc 没有这种约束 designted翻译差异。</p>
</li>
<li><p>中文翻译的怪怪的；<br> 我的翻译是：<br> <strong>目标是为了实例的初始化能保证类和其父类的所有成员得到初始化</strong></p>
<ol>
<li>全能初始化器的作用是为了保证当前类成员得到初始化</li>
<li>非全能初始化器应调用当前类全能初始化器</li>
<li>子类的全能初始化器必须调用父类的全能初始化器</li>
<li>如果父类的全能初始化器，子类没有实现，那么实例可以直接调用父类的全能初始化器初始化，子类成员变量没有初始化。为了解决这个问题，要么 抛异常，要么 重写父类的全能初始化器</li>
</ol>
<p> <strong>这块swift做成了编译检查，而且swift官方文档描述的更清楚</strong></p>
</li>
</ul>
<h3 id="17-实现descripion方法"><a href="#17-实现descripion方法" class="headerlink" title="17.实现descripion方法"></a>17.实现descripion方法</h3><ul>
<li>自己实现的建议加上类名称和对象地址</li>
<li>lldb里po 打印的是debugDescripion</li>
</ul>
<h3 id="18-使用不可变对象"><a href="#18-使用不可变对象" class="headerlink" title="18.使用不可变对象"></a>18.使用不可变对象</h3><ul>
<li>涉及到扩展的作用外部ro，内部rw可以点语法修改</li>
<li>成员变量对外不可变，修改交给类内部</li>
</ul>
<h3 id="19-命名方式"><a href="#19-命名方式" class="headerlink" title="19.命名方式"></a>19.命名方式</h3><h3 id="20-为私有方法加前缀"><a href="#20-为私有方法加前缀" class="headerlink" title="20.为私有方法加前缀"></a>20.为私有方法加前缀</h3><ul>
<li>oc由于动态机制，没有所谓的private函数</li>
<li>不要用_作为前缀，和苹果自带的冲突</li>
</ul>
]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Tranquilpeak主题配置</title>
    <url>/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hexo Tranquilpeak 主题配置</p>
<a id="more"></a>

<p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/09/08/Markdown/</url>
    <content><![CDATA[<p>常用Markdown编辑工具和语法</p>
<a id="more"></a>
<h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>网站：<a href="http://typora.io/">http://typora.io</a><br>支持Mac windows</p>
<h3 id="2-Dillinger"><a href="#2-Dillinger" class="headerlink" title="2.Dillinger"></a>2.Dillinger</h3><p>网站：<a href="http://dillinger.io/">http://dillinger.io</a><br>在线编辑</p>
<h3 id="3-印象笔记"><a href="#3-印象笔记" class="headerlink" title="3.印象笔记"></a>3.印象笔记</h3><p>支持多平台</p>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><blockquote>
<p><code># 大标题(注意有空格)</code><br><code>### 次标题 </code><br><code>##### 依次递减</code><br><code>*斜体*</code><br><code>**重点**</code><br><code>- list 列表(支持层级)</code><br><code>&gt; hello 引用样式(支持层级)</code><br><code>-[] checkBox 代办</code><br><code>*** 分隔线</code><br><code>--- 分隔线</code><br><code>|   |   |</code><br><code>|-|-|</code><br><code>|   |   |</code><br>表格(各个工具可能有差异，typora支持的好)<code> </code> <code>  代码块` 两行之间 `</code>c++ 根据语法着色`</p>
</blockquote>
<p>更多语法：<br><a href="https://www.jianshu.com/p/b03a8d7b1719">https://www.jianshu.com/p/b03a8d7b1719</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>架构学习的记录</p>
<a id="more"></a>
<h3 id="组件化设计"><a href="#组件化设计" class="headerlink" title="组件化设计"></a>组件化设计</h3><p>1.功能模块，互相解耦，通过中间层调用<br>2.公共组件抽离，统一维护管理<br>3.开发人员只做业务</p>
<p>优点：插件化，业务调整，之间互不影响<br>缺点：公共组件的统一维护可以提高效率，但也存在风险</p>
<h3 id="极端分离设计"><a href="#极端分离设计" class="headerlink" title="极端分离设计"></a>极端分离设计</h3><p>非专业叫法<br>1.所有模块、及其涉及的通用模块完全独立管理，完全解耦<br>2.模块之间 字典数据传递</p>
<p>优点：完全的模块分离<br>缺点：开发成本高，适合大型、多开发团队的App</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>挖坑，持续填坑</p>
<a id="more"></a>

<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>C负责M和V的对象管理和生命周期</li>
<li>M和V完全分离</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>C的业务负担较重</li>
</ul>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul>
<li>MVP+C ，本质还有C的存在</li>
<li>C持有P对象，P弱引用C</li>
<li>P的定位和MVC中的C类似，相当于把C的工作拆分成多个P，每个P负责部分业务功能，</li>
<li>C负责管理P对象管理和生命周期，对P做业务扩展</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul>
<li>MVVM+C   类似MVP，C可以有多个VM</li>
<li>VM持有M对象，持有V的对象</li>
<li>V不引用VM的头文件，只声明类型；和M分离</li>
<li>数据响应不再是VM发起，有V建立观察器去监听变化；<br>  实现方法：kvo，KVOController，RAC</li>
</ul>
<h5 id="优点：-进一步减少了VM的负担"><a href="#优点：-进一步减少了VM的负担" class="headerlink" title="优点： 进一步减少了VM的负担"></a>优点： 进一步减少了VM的负担</h5><h3 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h3>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
