<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tranquilpeak主题配置</title>
    <url>/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hexo Tranquilpeak 主题配置</p>
<a id="more"></a>

<p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/09/08/Markdown/</url>
    <content><![CDATA[<p>常用Markdown编辑工具和语法</p>
<a id="more"></a>
<h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>网站：<a href="http://typora.io/">http://typora.io</a><br>支持Mac windows</p>
<h3 id="2-Dillinger"><a href="#2-Dillinger" class="headerlink" title="2.Dillinger"></a>2.Dillinger</h3><p>网站：<a href="http://dillinger.io/">http://dillinger.io</a><br>在线编辑</p>
<h3 id="3-印象笔记"><a href="#3-印象笔记" class="headerlink" title="3.印象笔记"></a>3.印象笔记</h3><p>支持多平台</p>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><blockquote>
<p><code># 大标题(注意有空格)</code><br><code>### 次标题 </code><br><code>##### 依次递减</code><br><code>*斜体*</code><br><code>**重点**</code><br><code>- list 列表(支持层级)</code><br><code>&gt; hello 引用样式(支持层级)</code><br><code>-[] checkBox 代办</code><br><code>*** 分隔线</code><br><code>--- 分隔线</code><br><code>|   |   |</code><br><code>|-|-|</code><br><code>|   |   |</code><br>表格(各个工具可能有差异，typora支持的好)<code> </code> <code>  代码块` 两行之间 `</code>c++ 根据语法着色`</p>
</blockquote>
<p>更多语法：<br><a href="https://www.jianshu.com/p/b03a8d7b1719">https://www.jianshu.com/p/b03a8d7b1719</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>架构学习的记录</p>
<a id="more"></a>
<h3 id="组件化设计"><a href="#组件化设计" class="headerlink" title="组件化设计"></a>组件化设计</h3><p>1.功能模块，互相解耦，通过中间层调用<br>2.公共组件抽离，统一维护管理<br>3.开发人员只做业务</p>
<p>优点：插件化，业务调整，之间互不影响<br>缺点：公共组件的统一维护可以提高效率，但也存在风险</p>
<h3 id="极端分离设计"><a href="#极端分离设计" class="headerlink" title="极端分离设计"></a>极端分离设计</h3><p>非专业叫法<br>1.所有模块、及其涉及的通用模块完全独立管理，完全解耦<br>2.模块之间 字典数据传递</p>
<p>优点：完全的模块分离<br>缺点：开发成本高，适合大型、多开发团队的App</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>挖坑，持续填坑</p>
<a id="more"></a>

<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>C负责M和V的对象管理和生命周期</li>
<li>M和V完全分离</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>C的业务负担较重</li>
</ul>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul>
<li>MVP+C ，本质还有C的存在</li>
<li>C持有P对象，P弱引用C</li>
<li>P的定位和MVC中的C类似，相当于把C的工作拆分成多个P，每个P负责部分业务功能，</li>
<li>C负责管理P对象管理和生命周期，对P做业务扩展</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul>
<li>MVVM+C   类似MVP，C可以有多个VM</li>
<li>VM持有M对象，持有V的对象</li>
<li>V不引用VM的头文件，只声明类型；和M分离</li>
<li>数据响应不再是VM发起，有V建立观察器去监听变化；<br>  实现方法：kvo，KVOController，RAC</li>
</ul>
<h5 id="优点：-进一步减少了VM的负担"><a href="#优点：-进一步减少了VM的负担" class="headerlink" title="优点： 进一步减少了VM的负担"></a>优点： 进一步减少了VM的负担</h5><p>理解还是片面,待整理<br><a href="https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f">https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f</a><br><a href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm">https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm</a></p>
<h3 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h3>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>快速实现CollectionView的无限轮播器</title>
    <url>/2020/09/15/%E5%AE%9E%E7%8E%B0CollectionView%E7%9A%84%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/600/1*ZYZmgctLW304fZ3UqYheLw.gif" alt="avatar"><br>通过CollectionView快速实现一个无限轮播器,基于原生uikit</p>
<a id="more"></a>

<p>核心逻辑是在collection的dateSource</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> infiniteSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>infiniteSize可以指定一个非常大的值,但不要指定Int.max,会越界崩溃</p>
<p>例如<br><em>let infiniteSize = 100000</em></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func collection<span class="constructor">View(<span class="params">_</span> <span class="params">collectionView</span>: UICollectionView, <span class="params">cellForItemAt</span> <span class="params">indexPath</span>: IndexPath)</span> -&gt; UICollectionViewCell &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = collectionView.dequeue<span class="constructor">ReusableCell(<span class="params">withReuseIdentifier</span>: <span class="string">&quot;ColorCell&quot;</span>, <span class="params">for</span>: <span class="params">indexPath</span>)</span></span><br><span class="line">  guard <span class="keyword">let</span> size = listSize, size &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; return cell&#125;</span><br><span class="line">  cell.backgroundColor = colorList<span class="literal">[<span class="identifier">indexPath</span>.<span class="identifier">row</span> % <span class="identifier">size</span>]</span></span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cell通过对集合取余来控制集合索引<br>写完之后,现在可以实现向右的无限滑动,目前,但是向左还不行</p>
<h4 id="原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果"><a href="#原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果" class="headerlink" title="原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果"></a>原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果</h4><p>向左的思路是把默认的collection的索引指向itemSize的中间值,这样左右都有infiniteSize/2的数量了</p>
<p>可以在viewDidload中加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let size &#x3D; listSize, size &gt; 0 else &#123; return &#125;</span><br><span class="line">let midIndexPath &#x3D; IndexPath(row: infiniteSize &#x2F; size &#x2F; 2 * size, section: 0)</span><br><span class="line">             collectionView.scrollToItem(at: midIndexPath,</span><br><span class="line">                                              at: .centeredHorizontally,</span><br><span class="line">                                        animated: false)</span><br></pre></td></tr></table></figure>

<p>size是数据容器的大小,确保index指向容器的第一个</p>
<p>这样就完成了,方法比较取巧,</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>快速,方便</li>
<li>由于reuseable的cell并不会占用内存资源</li>
<li>原生实现,易于维护</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>伪无限循环,到了infinitySize上限,就滚不动了</li>
</ul>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
  <entry>
    <title>24个好用的Extension让代码更整洁</title>
    <url>/2020/09/21/24%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84Extension%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%95%B4%E6%B4%81/</url>
    <content><![CDATA[<h3 id="24个好用的Extension让代码更整洁-转自Medium"><a href="#24个好用的Extension让代码更整洁-转自Medium" class="headerlink" title="24个好用的Extension让代码更整洁(转自Medium)"></a>24个好用的Extension让代码更整洁(转自Medium)</h3><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/0_HQm1yU37T9Kn0Sqk.jpg" alt="avatar" style="zoom:50%;" />

<p>​    扩展(Extension)是swift和oc最好用的功能之一，能够无侵入的对现有系统类和工程添加新方法</p>
<p>作为一个iOS和Android的双料开发者，我经常能看到Android代码的功能方法更简洁，易懂；</p>
<p>当然通过扩展，我们也可以把这些特性使用在swift上，使swift项目也更精炼，更加好用</p>
<p>​    以下代码是基于swift，但其实对于oc，大部分也可以很容易的移植</p>
<a id="more"></a>



<h4 id="1-String-trim-and-Swift-trimmed"><a href="#1-String-trim-and-Swift-trimmed" class="headerlink" title="1.String.trim() and Swift.trimmed"></a>1.String.trim() and Swift.trimmed</h4><p>​    我们经常会用到string的trim功能，帮助把string里的空格，制表符，换行符等特殊符号去掉</p>
<p>扩展可以这么写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> trimmed: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">trim</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span>.trimmed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> str<span class="number">1</span> = <span class="string">&quot;  a b c d e   \n&quot;</span></span><br><span class="line"><span class="attribute">var</span> str<span class="number">2</span> = str<span class="number">1</span>.trimmed</span><br><span class="line"><span class="attribute">str1</span>.trim()</span><br></pre></td></tr></table></figure>



<h4 id="2-Int-toDouble-and-Double-toInt"><a href="#2-Int-toDouble-and-Double-toInt" class="headerlink" title="2. Int.toDouble() and Double.toInt()"></a>2. Int.toDouble() and Double.toInt()</h4><p>​    Int和Double,CGFloat的转换是项目中经常会用到.但实际使用上遇到Double(a),必须要求a是非可选类型,所以经常要做额外处理</p>
<p>可以对Int和Double的扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toDouble</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="type">Double</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toInt</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="type">Int</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">15.78</span></span><br><span class="line"><span class="keyword">let</span> b = a.toInt()</span><br></pre></td></tr></table></figure>



<h4 id="3-String-toDate-…-and-Date-toString-…"><a href="#3-String-toDate-…-and-Date-toString-…" class="headerlink" title="3. String.toDate(…) and Date.toString(…)"></a>3. String.toDate(…) and Date.toString(…)</h4><p>​    对Date和String的转换做易用的封装</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toDate</span><span class="params">(format: String)</span></span> -&gt; <span class="type">Date?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</span><br><span class="line">        df.dateFormat = format</span><br><span class="line">        <span class="keyword">return</span> df.date(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(format: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</span><br><span class="line">        df.dateFormat = format</span><br><span class="line">        <span class="keyword">return</span> df.string(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strDate = <span class="string">&quot;2020-08-10 15:00:00&quot;</span></span><br><span class="line"><span class="keyword">let</span> date = strDate.toDate(format: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> strDate2 = date?.<span class="built_in">toString</span>(format: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>​    </p>
<h4 id="4-Int-fenToYuan"><a href="#4-Int-fenToYuan" class="headerlink" title="4.Int.fenToYuan()"></a>4.Int.fenToYuan()</h4><p>​    没什么可说的,金额的分转元</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fenToYuan</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="type">Double</span>(<span class="keyword">self</span>) / <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fen = <span class="number">12350</span></span><br><span class="line"><span class="keyword">let</span> yuan = fen.fenToYuan()</span><br></pre></td></tr></table></figure>





<h4 id="5-String-asCoordinates"><a href="#5-String-asCoordinates" class="headerlink" title="5.String.asCoordinates()"></a>5.String.asCoordinates()</h4><p>​    string转成坐标,包括两个值,精度和纬度,在3D场景下还有高度数据,高度不是很常用</p>
<p>我们根据string里的逗号来解析,转成CLLocationCoordinate2D对象</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asCoordinates: <span class="type">CLLocationCoordinate2D?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> components = <span class="keyword">self</span>.components(separatedBy: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> components.<span class="built_in">count</span> != <span class="number">2</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> strLat = components[<span class="number">0</span>].trimmed</span><br><span class="line">        <span class="keyword">let</span> strLng = components[<span class="number">1</span>].trimmed</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dLat = <span class="type">Double</span>(strLat),</span><br><span class="line">            <span class="keyword">let</span> dLng = <span class="type">Double</span>(strLng) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: dLat, longitude: dLng)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strCoordinates = <span class="string">&quot;41.6168, 41.6367&quot;</span></span><br><span class="line"><span class="keyword">let</span> coordinates = strCoordinates.asCoordinates</span><br></pre></td></tr></table></figure>



<h4 id="6-String-asURL"><a href="#6-String-asURL" class="headerlink" title="6.String.asURL()"></a>6.String.asURL()</h4><p>​    URL是用处理链接的常用类,很灵活,可以连接不同组建,可以把各种类型处理为URLs,同时,也经常会配合着string的使用</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asURL: <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="type">URL</span>(string: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strUrl = <span class="string">&quot;https://medium.com&quot;</span></span><br><span class="line"><span class="keyword">let</span> url = strUrl.asURL</span><br></pre></td></tr></table></figure>



<h4 id="7-UIDevice-vibrate"><a href="#7-UIDevice-vibrate" class="headerlink" title="7.UIDevice.vibrate()"></a>7.UIDevice.vibrate()</h4><p>​    iPhone的震动效果是手机行业内做的最好的,可以主动调用这个</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AudioToolbox</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIDevice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">vibrate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1519</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.vibrate()</span><br></pre></td></tr></table></figure>





<h4 id="8-String-width-…-and-String-height-…"><a href="#8-String-width-…-and-String-height-…" class="headerlink" title="8.String.width(…) and String.height(…)"></a>8.String.width(…) and String.height(…)</h4><p>​    计算UILabel里的text占用的宽度,根据Font计算</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(withConstrainedWidth width: CGFloat, font: UIFont)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: width, height: .greatestFiniteMagnitude)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = <span class="keyword">self</span>.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [.font: font], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">width</span><span class="params">(withConstrainedHeight height: CGFloat, font: UIFont)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: .greatestFiniteMagnitude, height: height)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = <span class="keyword">self</span>.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [.font: font], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSAttributedString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(withConstrainedWidth width: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: width, height: .greatestFiniteMagnitude)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">width</span><span class="params">(withConstrainedHeight height: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: .greatestFiniteMagnitude, height: height)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> textHeight = text.height(withConstrainedWidth: <span class="number">100</span>, font: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>))</span><br></pre></td></tr></table></figure>



<h4 id="9-String-containsOnlyDigits"><a href="#9-String-containsOnlyDigits" class="headerlink" title="9.String.containsOnlyDigits"></a>9.String.containsOnlyDigits</h4><p>​    检查string是否只含有数字</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> containsOnlyDigits: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> notDigits = <span class="type">NSCharacterSet</span>.decimalDigits.inverted</span><br><span class="line">        <span class="keyword">return</span> rangeOfCharacter(from: notDigits, options: <span class="type">String</span>.<span class="type">CompareOptions</span>.literal, range: <span class="literal">nil</span>) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> digitsOnlyYes = <span class="string">&quot;1234567890&quot;</span>.containsOnlyDigits</span><br><span class="line"><span class="keyword">let</span> digitsOnlyNo = <span class="string">&quot;12345+789&quot;</span>.containsOnlyDigits</span><br></pre></td></tr></table></figure>



<h4 id="10-String-isAlphanumeric"><a href="#10-String-isAlphanumeric" class="headerlink" title="10.String.isAlphanumeric"></a>10.String.isAlphanumeric</h4><p>​    检查string是否只有数字和大小写字母,经常用于密码格式验证</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isAlphanumeric: <span class="type">Bool</span> &#123;</span><br><span class="line">        !isEmpty &amp;&amp; range(of: <span class="string">&quot;[^a-zA-Z0-9]&quot;</span>, options: .regularExpression) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alphanumericYes = <span class="string">&quot;asd3kJh43saf&quot;</span>.isAlphanumeric</span><br><span class="line"><span class="keyword">let</span> alphanumericNo = <span class="string">&quot;Kkncs+_s3mM.&quot;</span>.isAlphanumeric</span><br></pre></td></tr></table></figure>





<h3 id="11-String-下标"><a href="#11-String-下标" class="headerlink" title="11.String 下标"></a>11.String 下标</h3><p>​    swift的截取内容是比较繁琐的,比如:获取第n位内容,可以只设置一个Int参数</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span> (i: <span class="type">Int</span>) -&gt; <span class="type">Character</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[index(startIndex, offsetBy: i)]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountableRange</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start..&lt;end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountableClosedRange</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountablePartialRangeFrom</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(endIndex, offsetBy: -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">PartialRangeThrough</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; startIndex &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[startIndex...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">PartialRangeUpTo</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; startIndex &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[startIndex..&lt;end]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscript1 = <span class="string">&quot;Hello, world!&quot;</span>[<span class="number">7</span>...]</span><br><span class="line"><span class="keyword">let</span> subscript2 = <span class="string">&quot;Hello, world!&quot;</span>[<span class="number">7</span>...<span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<h4 id="12-UIImage-squared"><a href="#12-UIImage-squared" class="headerlink" title="12. UIImage.squared"></a>12. UIImage.squared</h4><p>​    如果需要用户提交一张方形照片,他们很少有标准的方形照片,但一般App里的头像控件往往都是圆形或者方形的</p>
<p>这个扩展可以快速的做处理</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> squared: <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originalWidth  = size.width</span><br><span class="line">        <span class="keyword">let</span> originalHeight = size.height</span><br><span class="line">        <span class="keyword">var</span> x: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">var</span> edge: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (originalWidth &gt; originalHeight) &#123;</span><br><span class="line">            <span class="comment">// landscape</span></span><br><span class="line">            edge = originalHeight</span><br><span class="line">            x = (originalWidth - edge) / <span class="number">2.0</span></span><br><span class="line">            y = <span class="number">0.0</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originalHeight &gt; originalWidth) &#123;</span><br><span class="line">            <span class="comment">// portrait</span></span><br><span class="line">            edge = originalWidth</span><br><span class="line">            x = <span class="number">0.0</span></span><br><span class="line">            y = (originalHeight - originalWidth) / <span class="number">2.0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// square</span></span><br><span class="line">            edge = originalWidth</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cropSquare = <span class="type">CGRect</span>(x: x, y: y, width: edge, height: edge)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> imageRef = cgImage?.cropping(to: cropSquare) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: imageRef, scale: scale, orientation: imageOrientation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    以上是类方法,也可以改为成实例方法</p>
<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> imgSquared = img.squared <span class="comment">// img.squared() for method</span></span><br></pre></td></tr></table></figure>

<h4 id="13-UIImage-resized-…"><a href="#13-UIImage-resized-…" class="headerlink" title="13.UIImage.resized(…)"></a>13.UIImage.resized(…)</h4><p>​    图片资源上传服务器的时候,会有大小限制,往往会处理成一张小尺寸照片</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">resized</span><span class="params">(maxSize: CGFloat)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> scale: <span class="type">CGFloat</span></span><br><span class="line">        <span class="keyword">if</span> size.width &gt; size.height &#123;</span><br><span class="line">            scale = maxSize / size.width</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            scale = maxSize / size.height</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> newWidth = size.width * scale</span><br><span class="line">        <span class="keyword">let</span> newHeight = size.height * scale</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(<span class="type">CGSize</span>(width: newWidth, height: newHeight))</span><br><span class="line">        draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: newWidth, height: newHeight))</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> newImage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img2 = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> img2Thumb = img2.resized(maxSize: <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<p>可以结合第12条一起使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> imgPrepared = img.squared?.resized(maxSize: <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<h4 id="14-Int-toString"><a href="#14-Int-toString" class="headerlink" title="14.Int.toString()"></a>14.Int.toString()</h4><p>​    一般可以用”‘\(num)”的方法把Int类型转为string,但是有个问题,如果你的num是可选类型,则会把”optional”也加进去,Kotlin处理可选类型比较优雅:对任意类型someVar?.toString,返回可选string</p>
<p>​    可惜,swift不允许对Any扩展,但至少可以给Int加上</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;\(self)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i1 = <span class="number">15</span></span><br><span class="line"><span class="keyword">let</span> i1AsString = i1.<span class="built_in">toString</span>()</span><br></pre></td></tr></table></figure>

<h4 id="15-Double-toString"><a href="#15-Double-toString" class="headerlink" title="15.Double.toString()"></a>15.Double.toString()</h4><p>​    和14同理,对Double加toString方法,但限制是保留两位小数</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>(format: <span class="string">&quot;%.02f&quot;</span>, <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d1 = <span class="number">15.67</span></span><br><span class="line"><span class="keyword">let</span> d1AsString = d1.<span class="built_in">toString</span>()</span><br></pre></td></tr></table></figure>



<h4 id="16-Double-toPrice"><a href="#16-Double-toPrice" class="headerlink" title="16.Double.toPrice()"></a>16.Double.toPrice()</h4><p>​    用的地方不多,转成”323,232,21.33$”这种格式</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toPrice</span><span class="params">(currency: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> nf = <span class="type">NumberFormatter</span>()</span><br><span class="line">        nf.decimalSeparator = <span class="string">&quot;,&quot;</span></span><br><span class="line">        nf.groupingSeparator = <span class="string">&quot;.&quot;</span></span><br><span class="line">        nf.groupingSize = <span class="number">3</span></span><br><span class="line">        nf.usesGroupingSeparator = <span class="literal">true</span></span><br><span class="line">        nf.minimumFractionDigits = <span class="number">2</span></span><br><span class="line">        nf.maximumFractionDigits = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (nf.string(from: <span class="type">NSNumber</span>(value: <span class="keyword">self</span>)) ?? <span class="string">&quot;?&quot;</span>) + currency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dPrice = <span class="number">16.50</span></span><br><span class="line"><span class="keyword">let</span> strPrice = dPrice.toPrice(currency: <span class="string">&quot;€&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="17-String-asDict"><a href="#17-String-asDict" class="headerlink" title="17.String.asDict"></a>17.String.asDict</h4><p>​    把JSON格式的string拆成字典,swift很方便</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asDict: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&quot;&#123;\&quot;hello\&quot;: \&quot;world\&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">let</span> dictFromJson = json.asDict</span><br></pre></td></tr></table></figure>

<h4 id="18-String-asArray"><a href="#18-String-asArray" class="headerlink" title="18.String.asArray"></a>18.String.asArray</h4><p>​    和上个类似,转成集合类型</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asArray: [<span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments) <span class="keyword">as</span>? [<span class="type">Any</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json2 = <span class="string">&quot;[1, 2, 3]&quot;</span></span><br><span class="line"><span class="keyword">let</span> arrFromJson2 = json2.asArray</span><br></pre></td></tr></table></figure>



<h4 id="19-String-asAttributedString"><a href="#19-String-asAttributedString" class="headerlink" title="19.String.asAttributedString"></a>19.String.asAttributedString</h4><p>​    有时我们需要一些跨平台的文本格式,最常用的是HTML格式,UILabel可以对粗体<strong>,下划线等要是做处理.把HTML格式转成NSAttributedString格式,然后给UILabel.attributedText赋值使用</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asAttributedString: <span class="type">NSAttributedString?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">NSAttributedString</span>(data: data, options: [.documentType: <span class="type">NSAttributedString</span>.<span class="type">DocumentType</span>.html], documentAttributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> htmlString = <span class="string">&quot;&lt;p&gt;Hello, &lt;strong&gt;world!&lt;/string&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> attrString = htmlString.asAttributedString</span><br></pre></td></tr></table></figure>



<h4 id="20-Bundle-appVersion"><a href="#20-Bundle-appVersion" class="headerlink" title="20.Bundle.appVersion"></a>20.Bundle.appVersion</h4><p>​    可以从Info.plist里加载app的版本信息,用途有:</p>
<ul>
<li>获取版本信息</li>
<li>检查是否有更新</li>
<li>展示版本信息</li>
<li>支持邮件里包含版本信息</li>
</ul>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> appVersion: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.infoDictionary?[<span class="string">&quot;CFBundleShortVersionString&quot;</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> mainAppVersion: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span>.main.appVersion</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> appVersion = <span class="type">Bundle</span>.mainAppVersion</span><br></pre></td></tr></table></figure>





<p>原文:</p>
<blockquote>
<p><a href="https://medium.com/better-programming/24-swift-extensions-for-cleaner-code-41e250c9c4c3">https://medium.com/better-programming/24-swift-extensions-for-cleaner-code-41e250c9c4c3</a></p>
</blockquote>
<h3 id="原文确实只有20个…"><a href="#原文确实只有20个…" class="headerlink" title="原文确实只有20个…"></a>原文确实只有20个…</h3>]]></content>
      <tags>
        <tag>效率</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(下)</title>
    <url>/2020/09/09/Effective-oc-%E7%AC%94%E8%AE%B0(%E4%B8%8B)/</url>
    <content><![CDATA[<p>6、7章<br>Block和GCD 37-46<br>系统框架 47-52</p>
<a id="more"></a>
<h3 id="37-理解Block"><a href="#37-理解Block" class="headerlink" title="37.理解Block"></a>37.理解Block</h3><ul>
<li>block在定义范围有效；栈block的生命周期，括号范围内</li>
<li>堆block，生命周期被管理</li>
</ul>
<h3 id="38-typedef-常用Block"><a href="#38-typedef-常用Block" class="headerlink" title="38.typedef 常用Block"></a>38.typedef 常用Block</h3><ul>
<li>typdef void(^DKBLock)(void *);</li>
<li>好处 修改方便、易读</li>
<li>建议根据使用场景，同类型block 声明为不同name</li>
</ul>
<h3 id="39-Block的好处"><a href="#39-Block的好处" class="headerlink" title="39.Block的好处"></a>39.Block的好处</h3><ul>
<li>delegate的缺点、如果包含多个委托，同一个函数要区分</li>
<li>block更集中，易维护、易读</li>
<li>建议多个参数，整理为一个handler，参数之间可以配合使用</li>
</ul>
<h3 id="40-块里的循环引用问题"><a href="#40-块里的循环引用问题" class="headerlink" title="40.块里的循环引用问题"></a>40.块里的循环引用问题</h3><ul>
<li>主动打破 块里将block对象释放（不执行就会有问题）</li>
<li>block持有者 使用完处理掉</li>
</ul>
<h3 id="41-多用派发队列，少用锁"><a href="#41-多用派发队列，少用锁" class="headerlink" title="41.多用派发队列，少用锁"></a>41.多用派发队列，少用锁</h3><ul>
<li>多个synchronized(self),共享锁，不推荐</li>
<li>异步调用设置方法，由于涉及拷贝块，衡量下拷贝和执行的速度</li>
</ul>
<h3 id="42-多用GCD，少用performSelector"><a href="#42-多用GCD，少用performSelector" class="headerlink" title="42.多用GCD，少用performSelector"></a>42.多用GCD，少用performSelector</h3><ul>
<li>performSelector局限多，参数支持最多2个</li>
<li>performSelector返回值限定id，基础类型需要做转换；返回值是c语言结构体就不建议用</li>
</ul>
<h3 id="43-GCD和NSOperation"><a href="#43-GCD和NSOperation" class="headerlink" title="43.GCD和NSOperation"></a>43.GCD和NSOperation</h3><ul>
<li>dispatch_once 执行一次；单例</li>
<li>NSOperation：可以取消、依赖、kvo观察任务状态</li>
</ul>
<h3 id="44-Dispatch-Group"><a href="#44-Dispatch-Group" class="headerlink" title="44.Dispatch Group"></a>44.Dispatch Group</h3><ul>
<li>dispatch_group_wait 阻塞等待完成执行</li>
<li>dispatch_group_notify 非阻塞等待完成</li>
<li>dispatch_apply </li>
</ul>
<h3 id="45-dispatch-once"><a href="#45-dispatch-once" class="headerlink" title="45.dispatch_once"></a>45.dispatch_once</h3><p>标准推荐写法</p>
<blockquote>
<p>static Class *instance = nil;<br>static dispatch_group_t token;<br>dispatch_once {&amp;token, ^{ instance = [[Class alloc]init]}}<br>return instance;</p>
</blockquote>
<ul>
<li>比synchronized快</li>
</ul>
<h3 id="46-不要使用dispatch-get-current-queue"><a href="#46-不要使用dispatch-get-current-queue" class="headerlink" title="46.不要使用dispatch_get_current_queue"></a>46.不要使用dispatch_get_current_queue</h3><h1 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h1><h3 id="47"><a href="#47" class="headerlink" title="47."></a>47.</h3>]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift下实现方法交换method swizzle(转自Medium)</title>
    <url>/2020/09/30/Swift%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2method%20swizzle/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/20200930102055.png"></p>
<p>方法交换是oc的技术,可以借助runtime的动态派发的特性实现两个方法的实现部分互换;</p>
<p>那么在swift如果实现呢?</p>
<a id="more"></a>

<p>在我们深入挖掘实现细节之前,需要对<code>selectors</code>相关的概念做一些说明</p>
<h4 id="什么是selectors"><a href="#什么是selectors" class="headerlink" title="什么是selectors"></a>什么是selectors</h4><p><code>selector</code>表示的一个类对象的方法的名称,<code>selector</code>没有具体实现,不做任何事情,唯一的目标的就是标识一个方法</p>
<h4 id="为什么使用方法交换-method-swizzling"><a href="#为什么使用方法交换-method-swizzling" class="headerlink" title="为什么使用方法交换(method swizzling)"></a>为什么使用方法交换(method swizzling)</h4><p>有以下场景可以用到:</p>
<p>方便的在App监测一个<code>ViewController</code>到另一个<code>ViewController</code>的切换;</p>
<p>具体方法是修改<code>viewWillAppear</code>的<code>selector,添加一些监控行为</code></p>
<p>实现如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">_swizzled_viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">	_swizzled_viewWillAppear(animated)</span><br><span class="line">	<span class="comment">//你要监控的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>@objc</code>说明用到oc的特性方法</p>
</li>
<li><p><code>dynamic</code>说明用到了动态</p>
</li>
<li><p>这不是会循环调用么?为什么要调用自己? 不会,因为切换后内括号内的调用其实是调用了原有的<code>ViewWillAppear</code></p>
</li>
</ul>
<p>通过<code>method_exchangeImplementations</code>方法,实现两个方法的交换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selector1 = #selector(<span class="type">UIViewController</span>.viewWillAppear(<span class="number">_</span>:))</span><br><span class="line"><span class="keyword">let</span> selector2 = #selector(<span class="type">UIViewController</span>.swizzled_viewWillAppear(:))</span><br><span class="line"><span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector1)!</span><br><span class="line"><span class="keyword">let</span> swizzleMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector2)!</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzleMethod)</span><br></pre></td></tr></table></figure>



<p>前面的实现整理到一起就完成了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">_swizzled_viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        _swizzled_viewWillAppear(animated)</span><br><span class="line">	<span class="comment">//你要监控的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">swizzleViewWillAppear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> selector1 = #selector(<span class="type">UIViewController</span>.viewWillAppear(<span class="number">_</span>:))</span><br><span class="line">        <span class="keyword">let</span> selector2 = #selector(<span class="type">UIViewController</span>._swizzled_viewWillAppear(<span class="number">_</span>:))</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector1)!</span><br><span class="line">        <span class="keyword">let</span> swizzleMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector2)!</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>别忘了调用方法交换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIViewController</span>.swizzleViewWillAppear()</span><br></pre></td></tr></table></figure>

<p>现在,<code>UIViewController</code>的所有实例和子类实例调用viewWillAppear时,都会触发<code> _swizzled_viewWillAppear</code></p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><p>有两点要注意:</p>
<ul>
<li><p>如果你要实现方法交换,你的类必须继承自<code>NSObject</code></p>
</li>
<li><p>你要交换的方法必须具有动态属性<code>@objc dynamic</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(上)</title>
    <url>/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0(%E4%B8%8A)/</url>
    <content><![CDATA[<p>前五章内容：<br>熟悉oc 1-5<br>对象、消息、runtime 6-14<br>接口与API 15-22<br>协议与分类 23-28<br>内存管理 29-36</p>
<a id="more"></a>
<h3 id="1-oc起源"><a href="#1-oc起源" class="headerlink" title="1.oc起源"></a>1.oc起源</h3><h3 id="2-减少头文件引用"><a href="#2-减少头文件引用" class="headerlink" title="2.减少头文件引用"></a>2.减少头文件引用</h3><ul>
<li>如果不使用类方法可以仅声明@class Class 即可</li>
</ul>
<h3 id="3-多用字面量"><a href="#3-多用字面量" class="headerlink" title="3.多用字面量"></a>3.多用字面量</h3><ul>
<li>代码整洁、直观</li>
<li>NSArray arrayWithObject：遇到nil不会崩溃，内部会判断</li>
</ul>
<h3 id="4-少用define"><a href="#4-少用define" class="headerlink" title="4.少用define"></a>4.少用define</h3><ul>
<li>建议使用const来替代：<ol>
<li>可以加static 控制作用域、避免冲突</li>
<li>类型含义明确，维护性好</li>
<li>static 编译器会自行优化为define</li>
</ol>
</li>
</ul>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><ul>
<li>占用1字节</li>
<li>type NS_ENUM oc枚举<ol>
<li>根据编译平台决定使用新、旧协议(c++)</li>
<li>新协议指的是底层数据类型存储</li>
<li>switch 处理enum分支；尽量不用default，覆盖每一个分支，避免新增enum，switch未处理的情况</li>
</ol>
</li>
</ul>
<h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><ul>
<li>类对象保管存储偏移量</li>
<li>@dynamic 配合CoreData动态添加方法</li>
</ul>
<h3 id="7-对象内部使用实例变量"><a href="#7-对象内部使用实例变量" class="headerlink" title="7.对象内部使用实例变量"></a>7.对象内部使用实例变量</h3><ul>
<li><p>self.var 语法</p>
<ol>
<li>效率低</li>
<li>可触发kvo，可使用懒加载</li>
</ol>
</li>
<li><p><code>_var</code> 语法</p>
<ol>
<li>不触发kvo</li>
<li>getter语法里使用</li>
</ol>
</li>
<li><p>折中方案</p>
<ol>
<li>写入用setter</li>
<li>读取用_var</li>
</ol>
</li>
</ul>
<h3 id="8-对象等同性"><a href="#8-对象等同性" class="headerlink" title="8.对象等同性"></a>8.对象等同性</h3><ul>
<li>isEqualToString比isEqual快</li>
<li>== 判断指针操作</li>
<li>hash()方法用于比较，自己实现；注意set时 的hash 碰撞问题</li>
<li>结构对象使用主键比较</li>
</ul>
<h3 id="9-类簇"><a href="#9-类簇" class="headerlink" title="9.类簇"></a>9.类簇</h3><ul>
<li>oc没有概念上的抽象类，oc的抽象类不写init</li>
<li>类簇类似抽象类的概念，提供接口，不提供实现</li>
<li>NSArray 里面是工厂，NSArray class 隐藏 无法通过实例访问<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[arr <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[str <span class="keyword">class</span>], [<span class="built_in">NSString</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">///分别打印</span></span><br><span class="line">__NSArray0|<span class="built_in">NSArray</span></span><br><span class="line">__NSCFConstantString|<span class="built_in">NSString</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-动态添加属性"><a href="#10-动态添加属性" class="headerlink" title="10.动态添加属性"></a>10.动态添加属性</h3><ul>
<li>本质是全局创建Map，以Class为key的外部表</li>
<li>示例：UIAlertView存在多个，通过此方法区分每个；不建议这么用；不好定位异常</li>
</ul>
<h3 id="11-消息派发"><a href="#11-消息派发" class="headerlink" title="11.消息派发"></a>11.消息派发</h3><ul>
<li>objc_msg_send 有两个隐藏参数 (id,SEL)</li>
<li>runtime</li>
<li>尾调用优化：去掉函数栈帧，优化</li>
</ul>
<h3 id="12-消息转发"><a href="#12-消息转发" class="headerlink" title="12.消息转发"></a>12.消息转发</h3><ul>
<li>resolveInstanceMethod/resolveClassMethod<ol>
<li>配合@dynamic</li>
</ol>
</li>
<li>备用接受者 forwardingTargetForSelector<ol>
<li>返回接收对象</li>
<li>1对1</li>
<li>快速</li>
</ol>
</li>
<li>完成消息转发forwardInvocation<ol>
<li>修改方法内容</li>
<li>1对多</li>
<li>慢</li>
</ol>
</li>
</ul>
<h3 id="13-方法交换"><a href="#13-方法交换" class="headerlink" title="13.方法交换"></a>13.方法交换</h3><ul>
<li>用于调试目的<ol>
<li>用户行为监控</li>
<li>调试异常</li>
<li>一般应用层不建议使用</li>
</ol>
</li>
</ul>
<h3 id="14-类对象意义"><a href="#14-类对象意义" class="headerlink" title="14.类对象意义"></a>14.类对象意义</h3><ul>
<li>判断对象关系 isKindOf isMemberOf；</li>
<li>示例：NSProxy 对于isKinfOf 对 class处理可能不一样(消息转发)</li>
<li>消息传递机制的前提</li>
</ul>
<h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul>
<li>c函数需要加前缀</li>
<li>lib对象，自己引用的第三方加前缀</li>
</ul>
<h3 id="16-全能初始化器"><a href="#16-全能初始化器" class="headerlink" title="16.全能初始化器"></a>16.全能初始化器</h3><ul>
<li><p>和swift的指定初始化器类似，swift 强制性 oc 没有这种约束 designted翻译差异。</p>
</li>
<li><p>中文翻译的怪怪的；<br> 我的翻译是：<br> <strong>目标是为了实例的初始化能保证类和其父类的所有成员得到初始化</strong></p>
<ol>
<li>全能初始化器的作用是为了保证当前类成员得到初始化</li>
<li>非全能初始化器应调用当前类全能初始化器</li>
<li>子类的全能初始化器必须调用父类的全能初始化器</li>
<li>如果父类的全能初始化器，子类没有实现，那么实例可以直接调用父类的全能初始化器初始化，子类成员变量没有初始化。为了解决这个问题，要么 抛异常，要么 重写父类的全能初始化器</li>
</ol>
<p> <strong>这块swift做成了编译检查，而且swift官方文档描述的更清楚</strong></p>
</li>
</ul>
<h3 id="17-实现descripion方法"><a href="#17-实现descripion方法" class="headerlink" title="17.实现descripion方法"></a>17.实现descripion方法</h3><ul>
<li>自己实现的建议加上类名称和对象地址</li>
<li>lldb里po 打印的是debugDescripion</li>
</ul>
<h3 id="18-使用不可变对象"><a href="#18-使用不可变对象" class="headerlink" title="18.使用不可变对象"></a>18.使用不可变对象</h3><ul>
<li>涉及到扩展的作用外部ro，内部rw可以点语法修改</li>
<li>成员变量对外不可变，修改交给类内部</li>
</ul>
<h3 id="19-命名方式"><a href="#19-命名方式" class="headerlink" title="19.命名方式"></a>19.命名方式</h3><h3 id="20-为私有方法加前缀"><a href="#20-为私有方法加前缀" class="headerlink" title="20.为私有方法加前缀"></a>20.为私有方法加前缀</h3><ul>
<li>oc由于动态机制，没有所谓的private函数</li>
<li>不要用_作为前缀，和苹果自带的冲突</li>
</ul>
<h3 id="21-oc错误类型"><a href="#21-oc错误类型" class="headerlink" title="21.oc错误类型"></a>21.oc错误类型</h3><ul>
<li>使用抽象类建议抛出异常</li>
<li>NSError** 使用</li>
</ul>
<h3 id="22-NSCopying协议"><a href="#22-NSCopying协议" class="headerlink" title="22.NSCopying协议"></a>22.NSCopying协议</h3><ul>
<li>copy方法调用copyWithZone；注意重写的应是copyWithZone</li>
</ul>
<h3 id="23-delegate对象间通信"><a href="#23-delegate对象间通信" class="headerlink" title="23.delegate对象间通信"></a>23.delegate对象间通信</h3><ul>
<li>delegate属性weak</li>
<li>自定义代理调用需要判断是否实现方法</li>
<li>位域代替responseToselector</li>
</ul>
<h3 id="24-类拆分成多个分类"><a href="#24-类拆分成多个分类" class="headerlink" title="24.类拆分成多个分类"></a>24.类拆分成多个分类</h3><ul>
<li>方便管理类</li>
<li>函数调用栈里可以看到分类信息</li>
</ul>
<h3 id="25-分类方法加前缀"><a href="#25-分类方法加前缀" class="headerlink" title="25.分类方法加前缀"></a>25.分类方法加前缀</h3><ul>
<li>分类加前缀</li>
<li>分类方法加前缀</li>
</ul>
<h3 id="26-分类中不能添加属性"><a href="#26-分类中不能添加属性" class="headerlink" title="26.分类中不能添加属性"></a>26.分类中不能添加属性</h3><ul>
<li>可以通过同名函数做到模拟属性的效果 不推荐</li>
<li>关联值添加属性 不推荐<br>感觉翻译的还是有点问题<br>原文：<em>“你可能通过属性特质修改了某个属性的管理语义”</em><br>理解：如果要给一个类批量修改属性@property，一般只记得在主类的头文件修改；如果设置了关联值，很可能忘记修改，维护性差</li>
</ul>
<h3 id="27-匿名分类隐藏实现细节"><a href="#27-匿名分类隐藏实现细节" class="headerlink" title="27.匿名分类隐藏实现细节"></a>27.匿名分类隐藏实现细节</h3><ul>
<li>和c++混编时，c++对象放到匿名分类里，避免重复引用头文件造成</li>
<li>修改ro属性，内部为rw</li>
<li>隐藏遵守的协议</li>
<li>私有属性，没在.h里，一般看不到；私有变量和放在impl里作用相同</li>
</ul>
<h3 id="28-协议实现匿名函数"><a href="#28-协议实现匿名函数" class="headerlink" title="28.协议实现匿名函数"></a>28.协议实现匿名函数</h3><ul>
<li>pop面向协议编程</li>
<li>隐藏实现，仅暴露协议内容</li>
</ul>
<h3 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h3><ul>
<li>retainCount 不推荐；因为如果autorelease了retainCount值不准确</li>
<li>mrc return [对象 autorelease],避免调用者不释放</li>
</ul>
<h3 id="30-ARC简化引用计数"><a href="#30-ARC简化引用计数" class="headerlink" title="30.ARC简化引用计数"></a>30.ARC简化引用计数</h3><ul>
<li>autorelease 后的返回函数 接收强类型对象 编译会自动retain</li>
<li>不能复写release函数</li>
<li>CF对象自行释放</li>
</ul>
<h3 id="31-dealloc作用"><a href="#31-dealloc作用" class="headerlink" title="31.dealloc作用"></a>31.dealloc作用</h3><ul>
<li>不要调用存取方法</li>
<li>可能并不会触发、在应用异常退出；可以在ApplicationWillTerminate里释放</li>
<li>某些文件句柄、socket系统映射文件，不要直接释放、调用相应close方法</li>
<li>释放c对象</li>
<li>释放通知、kvo</li>
<li></li>
</ul>
<h3 id="32-捕获异常"><a href="#32-捕获异常" class="headerlink" title="32.捕获异常"></a>32.捕获异常</h3><ul>
<li>arc 下不建议 try catch ，加很多辅助代码</li>
<li>如果objc++ 可以处理try catch</li>
</ul>
<h3 id="33-弱引用避免循环引用"><a href="#33-弱引用避免循环引用" class="headerlink" title="33.弱引用避免循环引用"></a>33.弱引用避免循环引用</h3><ul>
<li>weak属性 避免出现引用闭环</li>
</ul>
<h3 id="34-自动释放块"><a href="#34-自动释放块" class="headerlink" title="34.自动释放块"></a>34.自动释放块</h3><ul>
<li>可以在循环中创建对象使用，控制内存</li>
</ul>
<h3 id="35-僵尸对象调试"><a href="#35-僵尸对象调试" class="headerlink" title="35.僵尸对象调试"></a>35.僵尸对象调试</h3><ul>
<li>打开编译开关</li>
<li>原理：生成僵尸子类，由僵尸子类处理消息</li>
</ul>
<h3 id="36-retainCount"><a href="#36-retainCount" class="headerlink" title="36.retainCount"></a>36.retainCount</h3><ul>
<li>不建议用</li>
<li>由于autorelease，某一个时刻不代表真实值</li>
<li>优化原因，可能永远不为0</li>
<li>常量区对象也会有retainCount值，int.max</li>
</ul>
]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>frame 和 bounds</title>
    <url>/2020/09/11/frame%E5%92%8Cbounds%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="概念上frame以parentView为基准-bonuds以自己为基准"><a href="#概念上frame以parentView为基准-bonuds以自己为基准" class="headerlink" title="概念上frame以parentView为基准,bonuds以自己为基准"></a>概念上frame以parentView为基准,bonuds以自己为基准</h5><a id="more"></a>
<h3 id="在正常的情况下-非transform"><a href="#在正常的情况下-非transform" class="headerlink" title="在正常的情况下(非transform)"></a>在正常的情况下(非transform)</h3><p><strong>调整size</strong><br>1.frame和bonuds的size一样<br>2.调整view的frame的size,bonuds也会跟着改<br>3.调整bonuds的size,bonuds会以view的中心点固定调整,frame的size同步,但origin的坐标会根据发生变化.<br>例如bonuds的width由200变为160,变化值40,frame的origin.x 会 +20</p>
<p><strong>调整origin</strong><br>1.调整frame的origin,位置发生变化,bonuds的origin不变<br>2.调整bounds的origin(很少调整),位置发生绝对值变化,frame得origin跟着同步;特殊的是,如果有subView,<br>subView的绝对位置没变,不跟着父view调整</p>
<h3 id="transform下"><a href="#transform下" class="headerlink" title="transform下"></a>transform下</h3><p>1.bounds不变<br>2.frame是包含view的最小正方形</p>
<p>文字描述,不好理解<br>详细 参考<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603">https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603</a></p>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
  <entry>
    <title>当App启动时,发生了什么(转自Medium)</title>
    <url>/2020/09/15/%E5%BD%93App%E5%90%AF%E5%8A%A8%E6%97%B6,%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88(%E8%BD%AC%E8%87%AAMedium)/</url>
    <content><![CDATA[<p>​    你是否想过在按下app icon图标时到application::<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application?language=objc">didFinishLaunchingWithOptions</a>:?之间发生了什么</p>
<p>​    iPhone app技术上讲可以概括的描述为一个函数<a href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain">UIApplicationMain(<em>:</em>:<em>:</em>:)</a></p>
<p>​    下面一起探究以下其中原理</p>
<a id="more"></a>

<h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>​    如果你研究UIApplicationMain(<em>:</em>:<em>:</em>:)这个方法,你会发现他的返回值是Int32类型.其实,这个方法从来不会真的退出,直到app退出,和你的app生命周期一致</p>
<p>​    第一件事,app调用一个类<a href="https://developer.apple.com/documentation/uikit/uiapplication">UIApplication</a>这个类非常重要,是控制,协同app运行的关键</p>
<p>​    每个app只有一个该对象实例,是单例模式,UIApplication.shared就是这个单例对象</p>
<h4 id="UIApplicationDelegate"><a href="#UIApplicationDelegate" class="headerlink" title="UIApplicationDelegate"></a>UIApplicationDelegate</h4><p>​    另一件事,创建AppDelegate,是一个遵守<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate">UIApplicationDelegate</a>协议的对象,你可能对它已经很熟悉了,处理app交互的根对象</p>
<p>​    UIApplicationDelegate有一堆方法,用来管理你的app</p>
<p>​    你是否注意到@UIApplicationMain标记在类声明之前?UIApplicationMain(<em>:</em>:<em>:</em>:)根据这个标记知道哪个类是Appdelegate.这个类也是和app的生命周期同步.也被指向为UIApplication的代理对象</p>
<p>​    应用对象遇到重要的runtime事件时,会通知AppDelegate,例如app运行,内存警告,app终止,给予响应的机会</p>
<p>​    在iOS13,上述的一些响应职责被SceneDelegate接手处理了.负责app生命周期的响应职责由appDelegate处理,一些和app显示,窗口交互的响应职责由sceneDelegate处理</p>
<h4 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard?"></a>Storyboard?</h4><p>​    此时,app的基础功能已经就绪了,UIApplicationMain(<em>:</em>:<em>:</em>:)开始准备处理交互了</p>
<p>​    首先,需要找到main storyboard,这个行为是和Info.plist的key叫做”Main storyboard file base name”有关</p>
<p>​    如果使用storyboard绘制界面,app会实例化UIWindow,UIVindow是UIView的子类.这个实例化的window是你用户界面的基础</p>
<p>​    一旦实例化完成,window被赋值SceneDelegate的属性(在iOS13之前是AppDelegate的属性)</p>
<p>​    如果你观察SceneDelegate里的scene(_:willConnectTo:options:)方法,你能注意到瞎买你的注释:</p>
<blockquote>
<p>If using a storyboard, the <code>window</code> property will automatically be initialized and attached to the scene.</p>
</blockquote>
<p>​    现在开始window属性和app生命周期保持一致了</p>
<h4 id="ViewController的初始化"><a href="#ViewController的初始化" class="headerlink" title="ViewController的初始化"></a>ViewController的初始化</h4><p>​    用户虽然创建了UIWindow的实例,但是现在却看不到任何东西的,用户并不会直接和window交互,能看到的是window里的rootViewController属性</p>
<p>​    rootViewController包含着你的initial view controller,你可以通过storyboard指定initial view controller,在”Attributes inspector”,选中”Is initial view controller”</p>
<p>​    选中之后就被赋值给rootViewController属性,它是window现在唯一的直接的subview.其他的view都是rootview的subview</p>
<p>​    现在是时候调用application:didFinishLaunchingWithOptions:方法了</p>
<p>​    但window还是不可见,最一步需要调用<a href="https://developer.apple.com/documentation/uikit/uiwindow/1621601-makekeyandvisible">makeKeyAndVisible()</a>实例方法</p>
<p>​    此时app已经就绪,功能开始执行了</p>
<h4 id="无No-Storyboard"><a href="#无No-Storyboard" class="headerlink" title="无No Storyboard"></a>无No Storyboard</h4><p>​    有些项目不使用storyboard,靠纯代码绘制界面,这种情况下,你必须要在UIApplicationMain里自己写相关代码</p>
<p>​    在iOS13之前,写上述代码的位置在didFinishLaunchingWithOptions,现在要写在SceneDelegate<code>里的 </code>(_willConnectTo:options:)方法里</p>
<p>​    你要写的代码内容:</p>
<ul>
<li>实例化UIWindow,赋值给SceneDelegate<code>’s </code>window属性</li>
<li>实例化你的initial view controller并且赋值给window<code>的 </code>rootViewController属性</li>
<li>调用makeKeyAndVisible()展示界面</li>
</ul>
<p>代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="number">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    window = <span class="keyword">self</span>.window ?? <span class="type">UIWindow</span>()</span><br><span class="line">    window?.backgroundColor = .white</span><br><span class="line">    window?.rootViewController = <span class="type">ViewController</span>()</span><br><span class="line">    window?.makeKeyAndVisible()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = (scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    上述的过程都是不可见的,在app内部处理,很多人没有思考过其中的细节.是app生命周期重要的部分</p>
]]></content>
      <tags>
        <tag>Medium</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>配置高效的开发环境</title>
    <url>/2020/09/26/%E9%85%8D%E7%BD%AE%E9%AB%98%E6%95%88%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>xcode有很多提高效率的功能和配置,介绍一些可以提高效率的配置;包括debug,behavior,快捷键</p>
<a id="more"></a>

<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>cmd+\ 增加,删除断点<br>鼠标拖动断点蓝色标识,删除断点</p>
<h4 id="behavior"><a href="#behavior" class="headerlink" title="behavior"></a>behavior</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">open -a iTerm .</span><br></pre></td></tr></table></figure>
<p>打开终端,并进入到项目目录<br>把脚本放到工程根目录<br>在behavior里配置脚本,选择自定义快捷键,选择run脚本,指定工程根目录下的脚本(注意chmod+x 增加执行权限)<br>每次在xcode可以直接通过快捷键调用出终端,并且在当前项目目录里</p>
]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>提高开发效率的N种方法</title>
    <url>/2020/08/07/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>介绍几种提高mac下开发效率的方法、包括Xcode快捷键、vi快捷键、Alfred工作流、宏</p>
<a id="more"></a> 
<h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><pre><code>ctrl+f                光标向前
ctrl+b                光标向后
ctrl+a                光标行头
ctrl+e                光标行尾
ctrl+shift+f          向前选中
ctrl+shift+b          向后选中
ctrl+shift+a          向前选中至行头
ctrl+shift+e          向后选中至行尾
ctrl+k                向后删除当前行
ctrl+6                搜索当前文件函数
ctril+shift+,         显示scheme配置（build、run等）
cmd+,                 配置工程
ctrl+cmd+up/down      头文件和实现文件切换
ctrl+cmd+left/right   文件历史栈切换</code></pre>
<h3 id="vi快捷键"><a href="#vi快捷键" class="headerlink" title="vi快捷键"></a>vi快捷键</h3><pre><code>shift zz 快速保存退出</code></pre>
<p>​    </p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3>]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM学习</title>
    <url>/2020/10/12/LLVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>LLVM是可重用,可扩展的编译器和工具链后端的集合,可以方便的对新编程语言与新运行平台做最小化的兼容处理</p>
<a id="more"></a>

<h3 id="llvm官网"><a href="#llvm官网" class="headerlink" title="llvm官网"></a>llvm官网</h3><p><a href="https://llvm.org/">https://llvm.org</a></p>
<h3 id="为什么不再使用gcc"><a href="#为什么不再使用gcc" class="headerlink" title="为什么不再使用gcc"></a>为什么不再使用gcc</h3><h6 id="三段式编译工具链"><a href="#三段式编译工具链" class="headerlink" title="三段式编译工具链"></a>三段式编译工具链</h6><ul>
<li><p>gcc是GNU组织的开源的传统三段式的编译器套件</p>
</li>
<li><p>传统的三段式编译工具链如图:</p>
</li>
<li><p>分为前端,优化器,后端</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/krela2010/picstore/master/img/llvm.png"></p>
<ul>
<li><p>前端(Frontend):解析代码,检查静态语法,创建语法树(AST)</p>
</li>
<li><p>优化器(Optimizer):根据选项,做部分代码优化</p>
</li>
<li><p>后端(Backend):生成机器码(汇编)</p>
</li>
</ul>
<p><img src="http://www.aosabook.org/images/llvm/RetargetableCompiler.png" alt="[Retargetablity]"></p>
<p><strong>三段式的优点:</strong></p>
<p>编译器的维护者只需要关注前端的逻辑,和后端分离,避免了为增加一种语言,需要再重复实现后端逻辑的冗余工作量</p>
<p><strong>gcc的问题</strong></p>
<ul>
<li>gcc是一个完整的可执行文件,后端的优化器不能给其它语言提供重用的接口,即使是开源的,对于新增一种语言的代价也很大,需要重新实现相应的前端,优化等逻辑</li>
<li>对于苹果而言,gcc对于自家的语言支持不给力,效率和插件,工具支持薄弱等问题</li>
<li>性能问题gcc效率低,clang更快</li>
<li>对整体工具链的掌控lldb 支持新语言等</li>
</ul>
<h3 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h3><ul>
<li><p>llvm是指的是优化器和后端</p>
</li>
<li><p>llvm全称Low Level Virtual Machine(低级虚拟机),本身定位是虚拟机,类似jvm,属于编译器后端</p>
</li>
<li><p>IR:llvm最重要的一个部分就是IR全程为 Intermediate Representation (中间代码)</p>
</li>
</ul>
<p>优势:</p>
<ul>
<li><p>优化器:共享优化器,每次新增语言都可以重用以前的优化器</p>
</li>
<li><p>llvm下的三段式编译结构</p>
</li>
</ul>
<p><img src="http://www.aosabook.org/images/llvm/LLVMCompiler1.png" alt="[LLVM&#39;s Implementation of the Three-Phase Design]"></p>
<ul>
<li><p>Clang是c语言系列的前端编译器,</p>
</li>
<li><p>swift是swift语言的前端编译器,相比Clang多了sil</p>
<ul>
<li>Swift 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化</li>
</ul>
</li>
</ul>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><ol>
<li><p>预处理:</p>
<ol>
<li>宏展开</li>
</ol>
</li>
<li><p>词法分析</p>
<ol>
<li><p>词法分析</p>
</li>
<li><p>预处理代码文本转为token</p>
</li>
<li><p>不校验语义</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$clang</span> -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span></span><br></pre></td></tr></table></figure>

<p>展示为以token为单位的结构代码</p>
</li>
</ol>
</li>
<li><p>语法分析(Semantic Analysis)</p>
<ol>
<li><p>Clang中由Parser和Sema两个模块实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#clang</span> <span class="selector-tag">-fmodules</span> <span class="selector-tag">-fsyntax-only</span> <span class="selector-tag">-Xclang</span> <span class="selector-tag">-ast-dump</span> <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br></pre></td></tr></table></figure>

<p>生成语法树</p>
<p><strong>静态分析(Static Analysis)</strong></p>
<ol>
<li>通过语法树进行静态分析,找出非语法性错误</li>
<li>`模拟代码执行路径,</li>
<li>Checker</li>
</ol>
</li>
</ol>
</li>
<li><p>CodeGen-IR 代码生成</p>
<ol>
<li>与oc runtime桥接<ol>
<li>Class/Meta Class/Protocol/Category内存结构生成,放在指定section中</li>
<li>Method/Ivar/Property内存结构生成</li>
<li>Class中method_list/ivar_list/property_list结构生成</li>
</ol>
</li>
<li>BitCode<ol>
<li>IR 生成二进制码</li>
</ol>
</li>
</ol>
</li>
<li><p>生成汇编(Assemble)</p>
</li>
<li><p>生成Target相关Object(Mach-O)</p>
</li>
<li><p>链接</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/llvm-03.png"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p>
</li>
<li><p>《玩转编译器，Clang有意思》 –sunny孙源</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>持续继承</title>
    <url>/2020/10/12/%E6%8C%81%E7%BB%AD%E7%BB%A7%E6%89%BFCI/</url>
    <content><![CDATA[<p>持续集成是计划编译,运行测试用例的自动化集成的总称,可以在每次提交过程中自动编译,运行测试用,发现程序问题</p>
<p>常见持续集成工具 Bitrise, Github Actions, Jenkins</p>
<a id="more"></a>

<h3 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h3><h5 id="GitHub-Actions-是-GitHub-的持续集成服务，于2018年10月推出。"><a href="#GitHub-Actions-是-GitHub-的持续集成服务，于2018年10月推出。" class="headerlink" title="GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。"></a>GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。</h5><h5 id="GitHub-Actions-有一些自己的术语。"><a href="#GitHub-Actions-有一些自己的术语。" class="headerlink" title="GitHub Actions 有一些自己的术语。"></a>GitHub Actions 有一些自己的术语。</h5><ol>
<li><p><strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p>
</li>
<li><p><strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p>
</li>
<li><p><strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
</li>
<li><p><strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
</li>
</ol>
<h5 id="配置Actions"><a href="#配置Actions" class="headerlink" title="配置Actions"></a>配置Actions</h5><p>打开github reponstories </p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/githubactions.png"></p>
<p>点击<code>Actions</code></p>
<p>第一次使用的话,点击<code>Set up workflow</code></p>
<p>跳转到.yml文件编辑模式,Github是基于YAML文件格式配置集成工具</p>
<p>默认样式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Swift</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-latest</span> </span><br><span class="line">    <span class="comment">#运行所在系统平台,macos最新版本</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">swift</span> <span class="string">build</span> <span class="string">-v</span></span><br><span class="line">      <span class="comment">#需要修改</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">swift</span> <span class="string">test</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure>

<p>默认无法编译通过,需要进行部分修改</p>
<p>修改<code>run</code>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">run:xcodebuild</span> <span class="string">-project</span> <span class="string">&#x27;projectName.xcodeproj&#x27;</span> <span class="string">-scheme</span> <span class="string">projectName</span> <span class="string">-destination</span> <span class="string">&#x27;platform=iOS Simulator,name=iPhone 8&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你使用了pods,编译的是workspace,可以改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">run:xcodebuild</span> <span class="string">-workspace</span> <span class="string">&#x27;projectName.xcworkspace&#x27;</span> <span class="string">-scheme</span> <span class="string">projectName</span> <span class="string">-destination</span> <span class="string">&#x27;platform=iOS Simulator,name=iPhone 8&#x27;</span></span><br></pre></td></tr></table></figure>



<p>最终脚本效果:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Swift</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">xcodebuild</span> <span class="string">-workspace</span> <span class="string">&#x27;DYLiveStream/DYLiveStream.xcworkspace&#x27;</span> <span class="string">-scheme</span> <span class="string">DYLiveStream</span> <span class="string">-destination</span> <span class="string">&#x27;platform=iOS Simulator,name=iPhone 8&#x27;</span></span><br></pre></td></tr></table></figure>

<p>写完yaml之后提交,会开始尝试首次编译</p>
<p>如果编译成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/yaml.png"></p>
<p>失败的话,根据error信息进行定位</p>
<p>如果需要执行测试用例</p>
<p>添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">xcodebuild</span> <span class="string">-workspace</span> <span class="string">&#x27;DYLiveStream/DYLiveStream.xcworkspace&#x27;</span> <span class="string">-scheme</span> <span class="string">DYLiveStream</span> <span class="string">-destination</span> <span class="string">&#x27;platform=iOS Simulator,name=iPhone 8&#x27;</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>





<h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a></p>
<p>下载对应平台</p>
<p>以macos为例</p>
<p>用brew安装最新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install jenkins-lts</span><br></pre></td></tr></table></figure>

<p>安装指定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install jenkins-lts@YOUR_VERSION</span><br></pre></td></tr></table></figure>

<p>安装完成后,启动jenkins</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start jenkins-lts</span><br></pre></td></tr></table></figure>

<p>启动成功后</p>
<p><a href="http://localhost:8080/">http://localhost:8080</a> 进入配置页面</p>
<ol>
<li>从此目录复制密码到解锁 Jenkins</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Users/diaoke/.jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装推荐插件</p>
</li>
<li><p>安装完成后,进入管理页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/jenkins.png"></p>
</li>
<li><p>创建新job(create new job)</p>
<ul>
<li><p>创建<code>Freestyle project</code></p>
</li>
<li><p>输入git url</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/jenkins02.png"></p>
</li>
<li><p>添加build步骤</p>
<p>增加执行shell脚本步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/jenkins03.png"></p>
</li>
<li><p>在项目根目录ci.sh 内容和github actions里配置一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">xcodebuild -workspace &#x27;DYLiveStream/DYLiveStream.xcworkspace&#x27; -scheme DYLiveStream -destination &#x27;platform=iOS Simulator,name=iPhone 8&#x27;</span><br></pre></td></tr></table></figure>

<p>添加执行权限</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">chmod +x ci.sh</span><br></pre></td></tr></table></figure>

<p>提交</p>
</li>
</ul>
</li>
<li><p>构建触发器</p>
<p>本项目假定按照定时触发规则</p>
<p>用的是linux crontab的语法</p>
<p>选择<code>定时构建</code>,比如每5分钟构建一次,H代表hash,并非准确时间</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">H/5 <span class="emphasis">* *</span> <span class="emphasis">* *</span></span><br></pre></td></tr></table></figure>

<p>还有一些时间样例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line"></span><br><span class="line"># every fifteen minutes (perhaps at :<span class="number">07</span>, :<span class="number">22</span>, :<span class="number">37</span>, :<span class="number">52</span>)</span><br><span class="line">H/<span class="number">15</span> * * * *</span><br><span class="line"># every ten minutes <span class="keyword">in</span> the first half of every hour (three times, perhaps at :<span class="number">04</span>, :<span class="number">14</span>, :<span class="number">24</span>)</span><br><span class="line">H(<span class="number">0</span><span class="number">-29</span>)/<span class="number">10</span> * * * *</span><br><span class="line"># once every two hours at <span class="number">45</span> minutes past the hour starting at <span class="number">9</span>:<span class="number">45</span> AM <span class="keyword">and</span> finishing at <span class="number">3</span>:<span class="number">45</span> PM every weekday.</span><br><span class="line"><span class="number">45</span> <span class="number">9</span><span class="number">-16</span>/<span class="number">2</span> * * <span class="number">1</span><span class="number">-5</span></span><br><span class="line"># once <span class="keyword">in</span> every two hours slot between <span class="number">9</span> AM <span class="keyword">and</span> <span class="number">5</span> PM every weekday (perhaps at <span class="number">10</span>:<span class="number">38</span> AM, <span class="number">12</span>:<span class="number">38</span> PM, <span class="number">2</span>:<span class="number">38</span> PM, <span class="number">4</span>:<span class="number">38</span> PM)</span><br><span class="line">H H(<span class="number">9</span><span class="number">-16</span>)/<span class="number">2</span> * * <span class="number">1</span><span class="number">-5</span></span><br><span class="line"># once a day on the <span class="number">1</span>st <span class="keyword">and</span> <span class="number">15</span>th of every month except December</span><br><span class="line">H H <span class="number">1</span>,<span class="number">15</span> <span class="number">1</span><span class="number">-11</span> *</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>保存回到主页,点击<code>Build Now</code></p>
<p>构建任务开始执行</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>在Cocopods上发布framework(转自Medium)</title>
    <url>/2020/10/16/Cocopods%E4%B8%8A%E5%8F%91%E5%B8%83framework(%E8%BD%AC%E8%87%AAMedium)/</url>
    <content><![CDATA[<p>Cocopods是iOS上常用的负责管理framework的工具</p>
<a id="more"></a>

<h3 id="Cocopods是如何工作的"><a href="#Cocopods是如何工作的" class="headerlink" title="Cocopods是如何工作的"></a>Cocopods是如何工作的</h3><p>分为两部分介绍</p>
<ol>
<li>在App的项目里安装framework</li>
<li>在Cocopods发布framework</li>
</ol>
<h5 id="1-在iOS项目里安装framework"><a href="#1-在iOS项目里安装framework" class="headerlink" title="1. 在iOS项目里安装framework"></a>1. 在iOS项目里安装framework</h5><p>创建<code>Podfile</code>文件,里面要告诉Cocopods需要安装的framework名称,例如</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">target <span class="symbol">&#x27;MyApp</span>&#x27; <span class="keyword">do</span></span><br><span class="line">  pod <span class="symbol">&#x27;FrameworkA</span>&#x27;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>意思是要往MyApp项目里安装FrameworkA</p>
<p>完成配置后,要执行<code>pod install</code>执行安装步骤</p>
<p><code>pod install</code>会读取<code>Podfile</code>里的内容,执行相应步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/cocopods.png"></p>
<p><code>Cocopods</code>会从远程仓库查找相应的framework进行下载,链接到项目</p>
<p>注意,如果不指定版本,<code>Cocopods</code>会自动下载最新版本</p>
<p>执行完<code>pod install</code>后,<code>Cocopods</code>会自动生成workspace文件,并把目标framework链接到项目中</p>
<h5 id="2-在Cocopods发布framework"><a href="#2-在Cocopods发布framework" class="headerlink" title="2. 在Cocopods发布framework"></a>2. 在Cocopods发布framework</h5><p>这只发布的流程示例</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/cocopods2.png"></p>
<p>大体分为这几个步骤</p>
<ol>
<li>安装Cocopods</li>
<li>为framework创建git仓库</li>
<li>发布framework到git仓库</li>
<li>项目安装framework</li>
</ol>
<ul>
<li><p>安装Cocopods</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>为framework创建git仓库</p>
<p>先创建一个本地仓库</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">mkdir ~<span class="string">/MyFramework.git</span></span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/MyFramework.git</span></span><br><span class="line">git init <span class="params">--bare</span></span><br></pre></td></tr></table></figure>

<p>把MyFramework的项目内容绑定到刚才的git仓库</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">cd ~/MyFramework</span><br><span class="line">git init</span><br><span class="line">git remote add origin ~/MyFramework.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">0.0</span>.<span class="number">1</span> -m <span class="string">&quot;Version 0.0.1&quot;</span></span><br><span class="line">git push origin -u <span class="literal">master</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建本地指定的pod仓库</p>
<p>仓库用来发布自定义的framework,执行下列操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/MySpecs.git</span><br><span class="line">cd ~/MySpecs.git</span><br><span class="line">git init --bare</span><br><span class="line">git clone ~/MySpecs.git ~/MySpecs </span><br><span class="line">cd ~/MySpecs</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push origin -u master</span><br><span class="line">pod repo add my-specs ~/MySpecs.git</span><br><span class="line"><span class="meta">#</span><span class="bash">~/MySpecs.git 使用用绝对路径</span></span><br></pre></td></tr></table></figure>

<p>完成后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pod repo list</span><br></pre></td></tr></table></figure>

<p>定义的my-specs的pod源就被添加进来了</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/cocpods.png"></p>
</li>
</ul>
<ul>
<li><p>添加MyFramework的pod配置文件</p>
<p>执行操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; MyFramework.podspec &lt;&lt;-EOF</span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">    s.name         = &quot;MyFramework&quot;</span><br><span class="line">    s.version      = &quot;0.0.1&quot;</span><br><span class="line">    s.summary      = &quot;A brief description of MyFramework project.&quot;</span><br><span class="line">    s.description  = &lt;&lt;-DESC</span><br><span class="line">    An extended description of MyFramework project.</span><br><span class="line">    DESC</span><br><span class="line">    s.homepage     = &quot;http://your.homepage/here&quot;</span><br><span class="line">    s.license = &#123; :type =&gt; &#x27;Copyright&#x27;, :text =&gt; &lt;&lt;-LICENSE</span><br><span class="line">                   Copyright 2018</span><br><span class="line">                   Permission is granted to...</span><br><span class="line">                  LICENSE</span><br><span class="line">                &#125;</span><br><span class="line">    s.author             = &#123; &quot;$(git config user.name)&quot; =&gt; &quot;$(git config user.email)&quot; &#125;</span><br><span class="line">    s.source       = &#123; :git =&gt; &quot;$HOME/MyFramework.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;  #你的Framework的路径</span><br><span class="line">    s.source_files  = &quot;MyFramework/**/*.swift&quot;</span><br><span class="line">    s.resources = &quot;MyFramework/**/*.xib&quot;</span><br><span class="line">    s.platform = :ios</span><br><span class="line">    s.swift_version = &quot;4.2&quot;</span><br><span class="line">    s.ios.deployment_target  = &#x27;12.0&#x27;</span><br><span class="line">end</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>完成后,上传pod配置文件到repo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pod repo push my-specs MyFramework.podspec</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>cocpods的全部流程已经完成</p>
<p>​    之后就可以在项目里的Podfile添加<code>Myframework</code>的库了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">target &#x27;MyApp&#x27; do</span><br><span class="line">    use_frameworks!</span><br><span class="line">    pod &#x27;MyFramework&#x27;, &#x27;0.0.1&#x27;, :source =&gt; &quot;$HOME/MySpecs.git&quot;</span><br><span class="line">end</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>需要标明<code>use_frameworks!</code></p>
<p>source指定MySpecs.git位置</p>
<p><a href="https://medium.com/onfido-tech/distributing-swift-frameworks-via-cocoapods-152002b41783">https://medium.com/onfido-tech/distributing-swift-frameworks-via-cocoapods-152002b41783</a></p>
]]></content>
      <tags>
        <tag>cocopods</tag>
      </tags>
  </entry>
  <entry>
    <title>提高编译速度的方法(swift)</title>
    <url>/2020/10/22/2020-10-22-%E6%8F%90%E9%AB%98%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95(swift)/</url>
    <content><![CDATA[<p>文章中,我会针对编译的各个细节进行说明,一旦我们了解了整个编译过程,我们就可以尝试在各个编译过程进行优化,提高编译速度</p>
<a id="more"></a>

<p>先了解一下Xcode 编译过程结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build.png"></p>
<h5 id="预编译-PreProcessor"><a href="#预编译-PreProcessor" class="headerlink" title="预编译(PreProcessor)"></a>预编译(PreProcessor)</h5><ul>
<li><p>替换所有的宏</p>
</li>
<li><p>查找所有的依赖</p>
</li>
<li><p>处理预编译的指令</p>
</li>
</ul>
<h5 id="编译器-Compiler"><a href="#编译器-Compiler" class="headerlink" title="编译器(Compiler)"></a>编译器(Compiler)</h5><ul>
<li>转换源码为机器码(汇编)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build02.png"></p>
<p>这是swift的编译过程,具体流程可以参考我的这边文章</p>
<p><a href="https://krela2010.github.io/2020/10/12/LLVM%E5%AD%A6%E4%B9%A0/">https://krela2010.github.io/2020/10/12/LLVM%E5%AD%A6%E4%B9%A0/</a></p>
<h5 id="汇编-Assembler"><a href="#汇编-Assembler" class="headerlink" title="汇编(Assembler)"></a>汇编(Assembler)</h5><ul>
<li>将可读代码转为机器码</li>
<li>转为Mach-O文件,Mach-O是二进制文件,可以直接在iOS,Mac系统上运行</li>
</ul>
<h5 id="链接-Linker"><a href="#链接-Linker" class="headerlink" title="链接(Linker)"></a>链接(Linker)</h5><ul>
<li><p>把不同的Mach-O目标文件合并到一起,生成一个可执行文件</p>
<p> <em>Object Files + dylib, .a , .tbd =&gt; Single Executable file</em></p>
</li>
</ul>
<h5 id="加载-Loader"><a href="#加载-Loader" class="headerlink" title="加载(Loader)"></a>加载(Loader)</h5><ul>
<li>最后一步,把可执行程序加载到内存里,执行.Loader分配内存空间.加载dylibs,动态库</li>
</ul>
<h6 id="什么是Clean-Build"><a href="#什么是Clean-Build" class="headerlink" title="什么是Clean Build"></a>什么是<code>Clean Build</code></h6><p><em>无缓存,全部编译</em></p>
<h6 id="什么是Incremental-Build"><a href="#什么是Incremental-Build" class="headerlink" title="什么是Incremental Build"></a>什么是<code>Incremental Build</code></h6><p><em>针对修改的文件,进行编译</em></p>
<h5 id="把编译加速分为2个阶段"><a href="#把编译加速分为2个阶段" class="headerlink" title="把编译加速分为2个阶段"></a>把编译加速分为2个阶段</h5><ol>
<li>分析和设置编译选项,这个是最直接,最简单的方法</li>
<li>理解swift依赖关系,这个会影响到增量编译<code>Incremental Build</code></li>
</ol>
<h3 id="一阶段-修改Build-Settings"><a href="#一阶段-修改Build-Settings" class="headerlink" title="一阶段:修改Build Settings"></a>一阶段:修改Build Settings</h3><p><em>编译模式(Compliation Mode)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build03.png"></p>
<p>这个配置控制驱动<code>driver</code>和前端任务<code>frontend jobs</code>,先了解一下什么是驱动<code>driver</code>和前端<code>frontend</code></p>
<h6 id="驱动-Driver"><a href="#驱动-Driver" class="headerlink" title="驱动(Driver):"></a>驱动(Driver):</h6><p>​    任务调度,负责决定哪些文件需要编译或重新编译并运行(即作业)来执行编译和链接步骤</p>
<h6 id="前端任务-frontend-jobs"><a href="#前端任务-frontend-jobs" class="headerlink" title="前端任务(frontend jobs):"></a>前端任务(frontend jobs):</h6><p>​    被Driver调用,运行swift-frontend,执行编译,生成<code>PCH</code>文件,合并模块等.这一步骤相当耗时</p>
<h6 id="Primary-File-Mode"><a href="#Primary-File-Mode" class="headerlink" title="Primary File Mode"></a>Primary File Mode</h6><p>​    Driver把编译工作拆分出多个任务,每个任务读取模块中的所有文件,专注于编译主要的目标文件</p>
<p>​    <code>Primary File Mode</code>优点是做增量编译<code>Incremental Build</code>时,只针对过时需要编译的文件做处理,并且也可以同时运行多个编译工作,借助多核</p>
<h6 id="Whole-file-Mode"><a href="#Whole-file-Mode" class="headerlink" title="Whole file Mode"></a>Whole file Mode</h6><p>​    Driver只运行一个编译任务,无论多个文件.一个读取所有文件,编译所有文件</p>
<p>​    <code>Whole file Mode</code>优点可以结合整个模块做优化,并且避免了<code>Primary File Mode</code>里编译初期重复工作,缺点是总是全量重编译</p>
<p>结合两种特点,建议Debug使用<code>Primary File Mode</code>, Release使用<code>Whole file Mode</code> Xcode默认也是这样配置的</p>
<h5 id="Optimization-Mode"><a href="#Optimization-Mode" class="headerlink" title="Optimization Mode"></a>Optimization Mode</h5><p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build05.png"></p>
<p>​    优化模式下执行swift编译器,SIL和LLVM耗费了大量的时间和系统资源</p>
<p>​    非优化模式下,SIL和LLVM也会同样工作(仍会有一些优化处理),但是资源消耗有所下降,</p>
<p>​    </p>
<p>有3种优化类型,</p>
<p><code>-Onone</code> 代表无优化处理 </p>
<p><code>-Osize</code>代表优化文件大小</p>
<p><code>-O</code>代表优化编译速度</p>
<h5 id="复杂表达式和类型推断"><a href="#复杂表达式和类型推断" class="headerlink" title="复杂表达式和类型推断"></a>复杂表达式和类型推断</h5><p>类型推断是swift很实用的功能,可以不用指明类型,但也会增加大量的编译时间做类型推断工作</p>
<p><em>如何知道一个表达式耗费了大量的时间?</em></p>
<p>在开发环境,我们一般认为100ms以下是解析一个表达式的正常时间,如果超过100ms,我们要考虑做对表达式做一些优化,如何自动检查表达式的解析时间?</p>
<p>在<code>Build Settings — &gt; Swift Compiler — &gt; Custom Flags — &gt; Other Swift Flags</code></p>
<p>添加</p>
<p><code>-Xfrontend -warn-long-expression-type-checking=100</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build06.png"></p>
<p>还可以加一些级别例如250ms,500ms档</p>
<h5 id="删除dSYM文件"><a href="#删除dSYM文件" class="headerlink" title="删除dSYM文件"></a>删除dSYM文件</h5><p>dSYM文件(debug symbols file),记录App异常信息,存储在dSYM Bundle里,这个文件每次都会在编译时生成</p>
<p>可以Debug关闭,release开启</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build07.png" alt="image-20201022121522124"></p>
<h5 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h5><p>运行脚本会在你每次编译都要执行一遍,对此做优化</p>
<h3 id="二阶段-swift依赖关系"><a href="#二阶段-swift依赖关系" class="headerlink" title="二阶段:swift依赖关系"></a>二阶段:swift依赖关系</h3><p>编译器知道项目的文件依赖关系,可以决定哪些需要顺序编译,哪些可以并行编译</p>
<p>有3条编译规则</p>
<h5 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h5><p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build08.png"></p>
<p>如果函数体发生变化,swift不会重新编译相关依赖</p>
<h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><p>swift是类型安全语言,不关心你的函数体内的变化</p>
<h5 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h5><p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build09.png"></p>
<p>当在文件里添加新函数,新结构体或者新的扩展时,swift会编译文件所有相关依赖</p>
<h6 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h6><p>​    相较于oc,swift是基于文件编译的语言,你可以在你的文件里写任何的类和结构体,所以基于此,swift需要针对新增部分进行重编译</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build10.png"></p>
<p>AllExtensions.swift里添加了所有用到的extensions,如果继续增加,相应的所有的Extension的依赖也要重新编译</p>
<p>如果是按照右边图示,把Extensions放到不同文件,只会编译对应文件的依赖</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>不要把所有工具扩展放到一个文件里,拆分成不同文件</p>
<h5 id="规则3"><a href="#规则3" class="headerlink" title="规则3"></a>规则3</h5><p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/build11.png"></p>
<p>如果使用framework组件化结构,framework的任意变化都会是app重新编译所有文件</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>原文:</p>
<p><a href="https://swift.org/swift-compiler/#compiler-architecture">https://swift.org/swift-compiler/#compiler-architecture</a></p>
<p><a href="https://bytes.swiggy.com/advanced-techniques-to-speed-up-the-compile-time-in-xcode-27819cb3be59">https://bytes.swiggy.com/advanced-techniques-to-speed-up-the-compile-time-in-xcode-27819cb3be59</a></p>
]]></content>
      <tags>
        <tag>swift</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>优化 Objective-C runtime(wwdc2020)</title>
    <url>/2020/10/22/2020-10-22-%E4%BC%98%E5%8C%96-Objective-C-runtime(wwdc2020)/</url>
    <content><![CDATA[<p>wwdc2020上,苹果对oc的runtime的3个部分优化做了介绍</p>
<p>1.类数据结构变化</p>
<p>2.方法偏移列表</p>
<p>3.tagged pointers</p>
<a id="more"></a>



<h3 id="1-类数据结构变化"><a href="#1-类数据结构变化" class="headerlink" title="1.类数据结构变化"></a>1.类数据结构变化</h3><h6 id="Clean-memory"><a href="#Clean-memory" class="headerlink" title="Clean memory"></a>Clean memory</h6><p>指的是加载后不会发生变化的内存,是一个应用常驻内存的只读内存页集，iOS能够安全地从磁盘中移除或重载 <code>class_ro_t</code>这部分内存空间</p>
<h6 id="Dirty-memory"><a href="#Dirty-memory" class="headerlink" title="Dirty memory"></a>Dirty memory</h6><p>指的是无法被系统主动移除的常驻内存部分,运行过程中,可能会发生变化的内存<code>class_rw_t</code>这部分内存空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/runtimememory.png"></p>
<p><code>Dirty memory</code>比较昂贵,一旦加载进来就不能释放</p>
<p><code>Clean memory</code>可以进行移除,需要时再重新载入内存</p>
<p>由于各自的特性拆分出两种内存结构,所以可以看出,尽量把不改变的类结构放到<code>Clean memory</code>有助于提高性能</p>
<p>经过调查,在iphone运行时,大约会有30mb的<code>class_rw_t</code>的内存结构空间,</p>
<p>但其实只有10%的类会用到动态添方法等</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/runtime.png"></p>
<p>所以我们针对这部分做优化,预计可以节约14mb的内存空间</p>
<p>把可能动态变化的结构,放到<code>class_rw_ext_t</code>结构里,在需要的时候创建,</p>
<p>如果你的代码自行调用了<code>class_rw_t</code>,在这次更新后,可能会出现异常,</p>
<p>建议使用官方的Api进行访问,是安全的</p>
<p><code>class_getName</code></p>
<p><code>class_getSuperclass</code></p>
<p><code>class_copyMethodList</code></p>
<h3 id="2-方法列表偏移"><a href="#2-方法列表偏移" class="headerlink" title="2.方法列表偏移"></a>2.方法列表偏移</h3><p>方法列表包含三个部分,<code>selector</code> <code>imp</code> 和方法编码,在64位系统中,每个部分占用8个字节</p>
<p>加起来一个方法列表共占用24字节,<code>class_ro_t</code>是<code>clean memory</code></p>
<p>由于image内部的地址是连续的,寻址的过程中不需要64位的寻址空间,完全可以只用32位的偏移地址+image的地址就可以正常访问</p>
<p>经过验证methods占用的内存空间常驻大约是80mb,经过此方法优化可以节约40mb可观的空间</p>
<h6 id="方法交换-Method-swizzling-怎么办"><a href="#方法交换-Method-swizzling-怎么办" class="headerlink" title="方法交换(Method swizzling)怎么办?"></a>方法交换(Method swizzling)怎么办?</h6><p>由于优化后<code>method list</code>无法获取完整的方法地址,但如果你想交换方法实现,仍可以继续使用</p>
<p>通过创建一个全局<code>mappling table</code>,来存储需要交换的方法</p>
<p>相应的<code>swizzling method</code>得效率会有所降低,但实际上<code>swizzling method</code>使用的场景有限,这个全局表不会太大,效率也不会降低太多</p>
<p>还有一个优点,相比于原有<code>method list</code>结构,被”dirtied”的内存仅有全局的这个<code>Mapping table</code></p>
<p>这些变化都是无感的,不影响现有代码</p>
<p>新的方法偏移列表优化在<code>macOS Big Sur</code> <code>ios 14</code>等新版系统实现</p>
<p>当然也会兼容旧版本</p>
<p>如果在旧版本OS运行,按照对象读取会把<code>methods</code>的2个4字节偏移量按照一个8字节的全局地址处理,会造成异常,所以要使用<code>APIs</code></p>
<p><code>method_getName</code></p>
<p><code>method_getTypeEncoding</code></p>
<p><code>method_getImplementation</code></p>
<h3 id="3-Tagged-pointers"><a href="#3-Tagged-pointers" class="headerlink" title="3.Tagged pointers"></a><code>3.Tagged pointers</code></h3><p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/taggedpointers.png"></p>
<p><code>tagged pointers</code>是经过混淆的,很难被伪造</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/taggedpointers02.png"></p>
<p>从右至左,</p>
<p>第1位  <code>1</code>代表<code>Tagged pointers</code>,<code>0</code>代表对象指针</p>
<p>第2-4位 <code>Tag</code>表示对象类型 <code>3</code>代表NSNumber等</p>
<p>剩下位的是<code>payload</code></p>
<p>如果<code>Tag</code>位是7,会用第5-12位作为扩展使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/taggedpoint03.png"></p>
<p>就可以额外有256个标签类型,可以扩展更多的类型</p>
<p>要注意的是和intel架构不同,arm64是指针是反过来的,</p>
<p>这样就可以一次判断就确定是<code>tagged</code>或者<code>nil</code>,避免分开判断,节省了条件分支</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr &lt;= <span class="number">0</span>)<span class="comment">//tagged or nil</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/20201022204627.png"></p>
<p>今年做了优化,把<code>Tag</code>放到了低位</p>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/20201022204746.png"></p>
<p>ios14之后的有些处理指针位信息的会产生预料之外的问题</p>
<p>使用<code>APIs</code>处理</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([obj isKindOfClass:[NSString class]]) &#123;&#125; </span><br></pre></td></tr></table></figure>







<p><a href="https://developer.apple.com/videos/play/wwdc2020/10163/">https://developer.apple.com/videos/play/wwdc2020/10163/</a></p>
]]></content>
      <tags>
        <tag>oc</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio(Flutter) 快捷键</title>
    <url>/2020/10/30/2020-10-30-Android-Studio(Flutter)-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>以下是平时在Mac系统上用Android Studio进行开发时常用到的一些快捷键，在此记录一下.</p>
<p><strong>mac上按键符号</strong></p>
<blockquote>
<p>⌥ : option / alt<br> ⇧ : shift<br> ⌃ : control<br> ⌘ : command<br> ⎋ : esc</p>
</blockquote>
<a id="more"></a>



<h2 id="（一）查找-查看相关"><a href="#（一）查找-查看相关" class="headerlink" title="（一）查找/查看相关"></a>（一）查找/查看相关</h2><p>搜索任意内容<br> <code>双击shift</code></p>
<p>当前文件查找/替换<br> <code>cmd + F / cmd + R</code><br> <code>使用cmd + G，sft + cmd + G，</code>跳到下一个/上一个高亮的变量</p>
<p>查找下一个相同内容</p>
<p><code>ctrl+g</code></p>
<p>全局查找/替换<br> <code>sft + cmd + F</code> /  <code>sft + cmd + R</code></p>
<p>全局搜索类<br> <code>cmd + O</code></p>
<p>全局搜索类/方法/参数<br> <code>opt + cmd + O</code></p>
<p>打开最近访问的文件列表<br> <code>cmd + E</code></p>
<p>列出类中的所有成员<br> <code>command +fn + F12</code></p>
<p>类/方法在全局项目中引用情况（查看方法/变量/属性被谁调用了）<br> <code>opt + fn + F7</code> /  <code>cmd + 鼠标点击</code></p>
<p>类/方法在当前文件中引用情况<br> <code>cmd + fn + F7</code></p>
<p>方法被调用层级结构<br> <code>ctr + opt + H</code></p>
<p>查看接口的实现<br> <code>opt + cmd + B</code></p>
<p>跳转至超类的方法<br> <code>cmd + U</code></p>
<p>跳转至第几行<br> <code>cmd + L</code></p>
<p>返回到上次编辑位置<br> <code>cmd + [ / ]</code><br> <code>opt + cmd + ← / →</code></p>
<p>当前编辑的文件中结构快速导航<br> <code>cmd + fn + F12</code></p>
<p>列出函数方法一系列的有效参数<br> <code>cmd + P</code></p>
<p>跳转至错误或警告<br> <code>fn + F2</code></p>
<p>查看类／方法的注释文档<br> <code>fn + F1</code></p>
<h2 id="（二）控制操作相关"><a href="#（二）控制操作相关" class="headerlink" title="（二）控制操作相关"></a>（二）控制操作相关</h2><p>Surround with快速调出if,for,try…catch,while等环绕代码<br> <code>opt + cmd + T</code></p>
<p>快速生成模版代码块，如if,while,return<br> <code>cmd + J</code></p>
<p>快速生成getter／setter方法，构造方法，toString()方法等<br> <code>cmd + N</code></p>
<p>行尾自动添加分号，if后面自动加“(){ }”<br> <code>sft + cmd + enter</code></p>
<p>引入重写父类的方法<br> <code>ctr + O</code></p>
<p>引入接口或抽象类方法的实现<br> <code>ctr + I</code></p>
<p>下一步意图猜测<br> <code>opt + return</code></p>
<p>将最近使用的剪贴板内容选择插入到文本<br> <code>sft + cmd + V</code></p>
<p>注释与取消注释，注释效果 //…<br> <code>cmd + /</code></p>
<p>注释与取消注释，注释效果 /…/<br> <code>opt + cmd + /</code></p>
<p>上下移动代码<br> <code>opt + sft + up/down</code></p>
<p>上下代码行换位<br> <code>cmd + sft + up/down</code></p>
<p>单词间或驼峰间跳转<br> <code>Alt + ← / →</code></p>
<p>切换大小写<br> <code>sft + cmd + U</code></p>
<p>切换文件<br> <code>ctr + tab</code></p>
<p>选择区域<br> <code>opt + up/down</code><br> <strong>注：如果光标停留在大括号处，则选中整个大括号区域</strong></p>
<p>局部代码块展开/收缩<br> <code>cmd + + / cmd + -</code></p>
<p>全部代码块展开/收缩<br> <code>sft + cmd + + / sft + cmd + -</code></p>
<p>撤销/取消撤销<br> <code>cmd + Z / sft + cmd +Z</code></p>
<p>删除行<br> <code>cmd + C / cmd + delete</code></p>
<p>复制行<br> <code>cmd + D</code></p>
<p>合并行<br> <code>sft + ctr + J</code></p>
<p>列编辑<br> <code>Alt + 鼠标框选</code></p>
<p>格式化代码<br> <code>opt + cmd + L</code></p>
<p>自动缩进对齐<br> <code>ctr + alt + I</code></p>
<p>清除无效包引用<br> <code>opt + ctr + O</code></p>
<p>打开设置<br> <code>cmd + ,</code></p>
<p>隐藏窗口<br> <code>sft + esc</code></p>
<h2 id="（三）代码重构相关"><a href="#（三）代码重构相关" class="headerlink" title="（三）代码重构相关"></a>（三）代码重构相关</h2><p>类名／方法名／变量名 重命名操作<br> <code>sft + fn + F6</code></p>
<p>方法重构，方法抽离<br> <code>opt + cmd + M</code></p>
<p>抽离成方法参数<br> <code>opt + cmd + P</code></p>
<p>抽离为局部变量<br> <code>opt + cmd + V</code></p>
<p>抽离为成员变量<br> <code>opt + cmd + F</code></p>
<h2 id="（四）编译运行调试"><a href="#（四）编译运行调试" class="headerlink" title="（四）编译运行调试"></a>（四）编译运行调试</h2><p>编译源码<br> <code>cmd + fn + F9</code></p>
<p>运行<br> <code>ctr + R</code></p>
<p>调试<br> <code>ctr + B</code></p>
<p>Step Into（进入到代码）<br> <code>fn + F7</code></p>
<p>Step Over（跳到下一步）<br> <code>fn + F8</code></p>
<p>直接运行<br> <code>opt + cmd + R</code></p>
<p>退出调试<br> <code>cmd + fn + F2</code></p>
<h2 id="（五）版本控制"><a href="#（五）版本控制" class="headerlink" title="（五）版本控制"></a>（五）版本控制</h2><p>打开git操作列表<br> <code>ctr + V</code></p>
<p>提交修改<br> <code>cmd + K</code></p>
<p>推到服务器<br> <code>sft + cmd + K</code></p>
<h1 id="【option-command-b】"><a href="#【option-command-b】" class="headerlink" title="【option + command + b】"></a>【option + command + b】</h1><h3 id="查看抽象类或方法的子类实现"><a href="#查看抽象类或方法的子类实现" class="headerlink" title="查看抽象类或方法的子类实现"></a>查看抽象类或方法的子类实现</h3><h1 id="【option-shift-上下键】"><a href="#【option-shift-上下键】" class="headerlink" title="【option + shift + 上下键】"></a>【option + shift + 上下键】</h1><h3 id="移动代码"><a href="#移动代码" class="headerlink" title="移动代码"></a>移动代码</h3>]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Stateful Widget 生命周期</title>
    <url>/2020/11/08/2020-11-08-Stateful-Widget-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>研究Stateful Widget的生命周期是如何维护的</p>
<p>StatelessWidget很简单,只有一个build</p>
<a id="more"></a>

<p>StatefulWidget 生命周期相关函数有</p>
<h6 id="createState"><a href="#createState" class="headerlink" title="createState"></a>createState</h6><ul>
<li><p>Widget创建的第一步,立刻调用</p>
</li>
<li><p>可以被调用多次</p>
</li>
<li><p>调用后,buildContext已经生成</p>
</li>
<li><p>状态并未创建</p>
</li>
</ul>
<h6 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h6><ul>
<li><p>只会被调用一次,此时view没有渲染,所以buildContext还不能使用</p>
</li>
<li><p>必须调用super.initState</p>
</li>
</ul>
<h6 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h6><ul>
<li>在initState之后立即调用,view已经渲染完成,statefulwidget刷新时不会调用</li>
</ul>
<h6 id="build"><a href="#build" class="headerlink" title="build"></a>build</h6><ul>
<li>不能返回null</li>
<li>在didChangeDependencies之后调用</li>
<li>每次刷新,build都会重新调用</li>
<li>不要再build里添加其他非必要逻辑</li>
</ul>
<h6 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget"></a>didUpdateWidget</h6><ul>
<li>widget key发生变化时会调用,一般不会用</li>
</ul>
<h6 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate"></a>deactivate</h6><ul>
<li>widget将被remove时调用,也有可能重新放入render tree中</li>
</ul>
<h6 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h6><ul>
<li>当widget确实被销毁后调用</li>
</ul>
<h6 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h6><ul>
<li>mounted是个变量,当buildContext可用渲染结束时为true,dispose后变为false</li>
</ul>
<h4 id="监听App生命周期"><a href="#监听App生命周期" class="headerlink" title="监听App生命周期"></a>监听App生命周期</h4><ul>
<li>在statefulwidget 的state类添加<code>混入</code>WidgetsBindingObserver</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在initState里添加监听</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在dispose删除监听</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在state类里重写<code>didChangeAppLifecycleState(AppLifecycleState state)</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">    <span class="comment">// went to Background</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">    <span class="comment">// came back to Foreground</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>生命周期状态有4种</p>
<ul>
<li>resumed</li>
<li>inactive</li>
<li>paused</li>
<li>suspending</li>
</ul>
<p>转自<a href="https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7">https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>dart的语法糖和一些trick</title>
    <url>/2020/11/19/2020-11-19-dart%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E5%92%8C%E4%B8%80%E4%BA%9Btrick/</url>
    <content><![CDATA[<p>知道这些tips,可以写出更简洁的代码</p>
<a id="more"></a>

<h6 id="1-string的乘法"><a href="#1-string的乘法" class="headerlink" title="1.string的乘法"></a>1.string的乘法</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;🎄&#x27;</span> * i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 🎄</span></span><br><span class="line"><span class="comment">// 🎄🎄</span></span><br><span class="line"><span class="comment">// 🎄🎄🎄</span></span><br><span class="line"><span class="comment">// 🎄🎄🎄🎄</span></span><br><span class="line"><span class="comment">// 🎄🎄🎄🎄🎄</span></span><br></pre></td></tr></table></figure>

<h6 id="2-同步调用Future函数"><a href="#2-同步调用Future函数" class="headerlink" title="2.同步调用Future函数"></a>2.同步调用Future函数</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CovidAPI</span> </span>&#123;</span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; getCases() =&gt; Future.value(<span class="number">1000</span>);</span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; getRecovered() =&gt; Future.value(<span class="number">100</span>);</span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; getDeaths() =&gt; Future.value(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Future.wait</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> api = CovidAPI();</span><br><span class="line"><span class="keyword">final</span> values = <span class="keyword">await</span> Future.wait([</span><br><span class="line">    api.getCases(),</span><br><span class="line">    api.getRecovered(),</span><br><span class="line">    api.getDeaths(),</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">print</span>(values); <span class="comment">// [1000, 100, 10]</span></span><br></pre></td></tr></table></figure>

<h6 id="3-类里的call方法"><a href="#3-类里的call方法" class="headerlink" title="3.类里的call方法"></a>3.类里的call方法</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PasswordValidator</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> call(<span class="built_in">String</span> password) &#123;</span><br><span class="line">    <span class="keyword">return</span> password.length &gt; <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以像方法一样直接通过实例对象调用,</p>
<p>两种调用方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> validator = PasswordValidator();</span><br><span class="line"><span class="comment">// can use it like this:</span></span><br><span class="line">validator(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">validator(<span class="string">&#x27;test1234&#x27;</span>);</span><br><span class="line"><span class="comment">// no need to use it like this:</span></span><br><span class="line">validator.call(<span class="string">&#x27;not-so-frozen-arctic&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h6 id="4用”-call-”调用回调函数避免为空"><a href="#4用”-call-”调用回调函数避免为空" class="headerlink" title="4用”?.call()”调用回调函数避免为空"></a>4用”?.call()”调用回调函数避免为空</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDraggable</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CustomDraggable(&#123;Key key, <span class="keyword">this</span>.onDragCompleted&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> VoidCallback? onDragCompleted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _dragComplete() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement me</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是传统写法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _dragComplete() &#123;</span><br><span class="line">    <span class="keyword">if</span> (onDragCompleted != <span class="keyword">null</span>) &#123;</span><br><span class="line">      onDragCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>另一种简便写法,为null就不会调用了,和上面等效</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; _dragComplete() <span class="keyword">async</span> &#123;</span><br><span class="line">   onDragCompleted?.call();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h6 id="5-函数作为参数传递"><a href="#5-函数作为参数传递" class="headerlink" title="5.函数作为参数传递"></a>5.函数作为参数传递</h6><p>dart里函数也是一等公民,具有和其他变量同等待遇</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> sayHi = (name) =&gt; <span class="string">&#x27;Hi, <span class="subst">$name</span>&#x27;</span>;</span><br><span class="line">  welcome(sayHi, <span class="string">&#x27;Andrea&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> welcome(<span class="built_in">String</span> <span class="built_in">Function</span>(<span class="built_in">String</span>) greet,</span><br><span class="line">             <span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(greet(name));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Welcome to this course&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="6-容器判断和容器展开"><a href="#6-容器判断和容器展开" class="headerlink" title="6.容器判断和容器展开"></a>6.容器判断和容器展开</h6><p>…可以把容器的元素展开,也可以在容器里添加if判断语法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addRatings = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> restaurant = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;Pizza Mario&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cuisine&#x27;</span>: <span class="string">&#x27;Italian&#x27;</span>,</span><br><span class="line">  <span class="keyword">if</span> (addRatings) ...&#123;</span><br><span class="line">    <span class="string">&#x27;avgRating&#x27;</span>: <span class="number">4.3</span>,</span><br><span class="line">    <span class="string">&#x27;numRatings&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="7-安全遍历map”-entries”"><a href="#7-安全遍历map”-entries”" class="headerlink" title="7.安全遍历map”.entries”"></a>7.安全遍历map”.entries”</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> timeSpent.entries) &#123;</span><br><span class="line">  <span class="comment">// do something with keys and values</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;entry.key&#125;</span>: <span class="subst">$&#123;entry.value&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比遍历key安全</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> timeSpent.keys) &#123;</span><br><span class="line">  <span class="keyword">final</span> value = timeSpent[key];</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$key</span>: <span class="subst">$value</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现如果key对应的value是null,就会报错</p>
<h6 id="8-使用命名构造函数-更具有维护性-可读性"><a href="#8-使用命名构造函数-更具有维护性-可读性" class="headerlink" title="8.使用命名构造函数,更具有维护性,可读性"></a>8.使用命名构造函数,更具有维护性,可读性</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span> </span>&#123;</span><br><span class="line">  Temperature.celsius(<span class="keyword">this</span>.celsius);</span><br><span class="line">  Temperature.fahrenheit(<span class="built_in">double</span> fahrenheit)</span><br><span class="line">    : celsius = (fahrenheit - <span class="number">32</span>) / <span class="number">1.8</span>;</span><br><span class="line">  <span class="built_in">double</span> celsius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="9-Getter和Setter"><a href="#9-Getter和Setter" class="headerlink" title="9.Getter和Setter"></a>9.Getter和Setter</h6><p>dart里的getter和setter的语法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span> </span>&#123;</span><br><span class="line">  Temperature.celsius(<span class="keyword">this</span>.celsius);</span><br><span class="line">  Temperature.fahrenheit(<span class="built_in">double</span> fahrenheit)</span><br><span class="line">    : celsius = (fahrenheit - <span class="number">32</span>) / <span class="number">1.8</span>;</span><br><span class="line">  <span class="built_in">double</span> celsius;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> fahrenheit</span><br><span class="line">    =&gt; celsius * <span class="number">1.8</span> + <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">set</span> fahrenheit(<span class="built_in">double</span> fahrenheit)</span><br><span class="line">    =&gt; celsius = (fahrenheit - <span class="number">32</span>) / <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> temp1 = Temperature.celsius(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">print</span>(temp1.fahrenheit);</span><br><span class="line"><span class="keyword">final</span> temp2 = Temperature.fahrenheit(<span class="number">90</span>);</span><br><span class="line">temp2.celsius = <span class="number">28</span>;</span><br></pre></td></tr></table></figure>



<p>10.用<code>_</code>下划线代替未使用的参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemBuilder: (context, index) =&gt; ListTile(</span><br><span class="line">        title: Text(<span class="string">&#x27;all the same&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      itemCount: <span class="number">10</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用context,index,可以写成如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">istView.builder(</span><br><span class="line">  itemBuilder: (_, __) =&gt; ListTile(</span><br><span class="line">    title: Text(<span class="string">&#x27;all the same&#x27;</span>),</span><br><span class="line">  ),</span><br><span class="line">  itemCount: <span class="number">10</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>_和__代表不同的参数</p>
<h6 id="11-单例实现"><a href="#11-单例实现" class="headerlink" title="11.单例实现"></a>11.单例实现</h6><p>dart的单例实现方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_system.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> </span>&#123;</span><br><span class="line">  FileSystem._();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> instance = FileSystem._();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法实例化,仅能通过以下方式访问</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// some_other_file.dart</span></span><br><span class="line"><span class="keyword">final</span> fs = FileSystem.instance;</span><br><span class="line"><span class="comment">// do something with fs</span></span><br></pre></td></tr></table></figure>



<p>12.Set</p>
<p>如果需要一个不包含重复元素的集合,那么使用Set</p>
<p>一个细节,如果使用final 修饰set,有重复元素只会提示warning</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set is final, compiles</span></span><br><span class="line"><span class="keyword">final</span> citiesSet = &#123;</span><br><span class="line">  <span class="string">&#x27;London&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Paris&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Rome&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;London&#x27;</span>, <span class="comment">// Two elements in a set literal shouldn&#x27;t be equal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果用const修复,会提示无法编译</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set is const, doesn&#x27;t compile</span></span><br><span class="line"><span class="keyword">const</span> citiesSet = &#123;</span><br><span class="line">  <span class="string">&#x27;London&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Paris&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Rome&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;London&#x27;</span>, <span class="comment">// Two elements in a constant set literal can&#x27;t be equal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<p><code>TODO</code></p>
<h2 id="15-Common-Stream-constructors"><a href="#15-Common-Stream-constructors" class="headerlink" title="15. Common Stream constructors"></a><a href="https://codewithandrea.com/videos/2020-11-16-top-dart-tips-and-tricks-for-flutter-devs/#15-common-stream-constructors">15. Common Stream constructors</a></h2><p>The Stream class also comes with some handy constructors. Here are the most common ones:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>from<span class="constructor">Iterable([1, 2, 3])</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>value(<span class="number">10</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>empty<span class="literal">()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>error(<span class="constructor">Exception(&#x27;<span class="params">something</span> <span class="params">went</span> <span class="params">wrong</span>&#x27;)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>from<span class="constructor">Future(Future.<span class="params">delayed</span>(Duration(<span class="params">seconds</span>: 1)</span>,<span class="function"> <span class="params">()</span> =&gt;</span> <span class="number">42</span>));</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span>periodic(<span class="constructor">Duration(<span class="params">seconds</span>: 1)</span>,<span class="function"> (<span class="params">index</span>) =&gt;</span> index);</span><br></pre></td></tr></table></figure>

<ul>
<li>use <code>Stream.fromIterable</code> to create a <code>Stream</code> from a list of values.</li>
<li>use <code>Stream.value</code> if you have just one value.</li>
<li>use <code>Stream.empty</code> to create an empty stream.</li>
<li>use <code>Stream.error</code> to create a stream that contains an error value.</li>
<li>use <code>Stream.fromFuture</code> to create a stream that will contain only one value, and that value will be available when the future completes.</li>
<li>use <code>Stream.periodic</code> to create a periodic stream of events. You can specify a <code>Duration</code> as the time interval between events, and an anonymous function to generate each value given its index in the stream.</li>
</ul>
<h2 id="16-Sync-and-Async-Generators"><a href="#16-Sync-and-Async-Generators" class="headerlink" title="16. Sync and Async Generators"></a><a href="https://codewithandrea.com/videos/2020-11-16-top-dart-tips-and-tricks-for-flutter-devs/#16-sync-and-async-generators">16. Sync and Async Generators</a></h2><p>In Dart we can define a <strong>synchronous</strong> generator as a function that returns an <code>Iterable</code>:</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">Iterable&lt;<span class="built_in">int</span>&gt; <span class="built_in">count</span>(<span class="built_in">int</span> <span class="built_in">n</span>) sync* &#123;</span><br><span class="line">  for (<span class="built_in">var</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This uses the <code>sync*</code> syntax. Inside the function we can “generate” or <code>yield</code> multiple values. These will be returned as an <code>Iterable</code> when the function completes.</p>
<hr>
<p>On the other hand, an <strong>asynchronous</strong> generator is a function that returns a <code>Stream</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;<span class="keyword">int</span>&gt; <span class="title">countStream</span>(<span class="params"><span class="keyword">int</span> n</span>) <span class="keyword">async</span>*</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This uses this <code>async*</code> syntax. Inside the function we can <code>yield</code> values just like in the synchronous case.</p>
<p>But if we want we can <code>await</code> on Future-based APIs, because this is an <strong>asynchronous</strong> generator:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; count<span class="constructor">Stream(<span class="params">int</span> <span class="params">n</span>)</span> async* &#123;</span><br><span class="line">  <span class="keyword">for</span> (var i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// dummy delay - this could be a network request</span></span><br><span class="line">    await <span class="module-access"><span class="module"><span class="identifier">Future</span>.</span></span>delayed(<span class="constructor">Duration(<span class="params">seconds</span>: 1)</span>);</span><br><span class="line">    yield i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转自</p>
<p><a href="https://codewithandrea.com/videos/2020-11-16-top-dart-tips-and-tricks-for-flutter-devs/#8-use-named-constructors-and-initializer-lists-for-more-ergonomic-apis">https://codewithandrea.com/videos/2020-11-16-top-dart-tips-and-tricks-for-flutter-devs/#8-use-named-constructors-and-initializer-lists-for-more-ergonomic-apis</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
</search>
