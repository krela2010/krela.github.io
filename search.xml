<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tranquilpeak主题配置</title>
    <url>/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hexo Tranquilpeak 主题配置</p>
<a id="more"></a>

<p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/09/08/Markdown/</url>
    <content><![CDATA[<p>常用Markdown编辑工具和语法</p>
<a id="more"></a>
<h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>网站：<a href="http://typora.io/">http://typora.io</a><br>支持Mac windows</p>
<h3 id="2-Dillinger"><a href="#2-Dillinger" class="headerlink" title="2.Dillinger"></a>2.Dillinger</h3><p>网站：<a href="http://dillinger.io/">http://dillinger.io</a><br>在线编辑</p>
<h3 id="3-印象笔记"><a href="#3-印象笔记" class="headerlink" title="3.印象笔记"></a>3.印象笔记</h3><p>支持多平台</p>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><blockquote>
<p><code># 大标题(注意有空格)</code><br><code>### 次标题 </code><br><code>##### 依次递减</code><br><code>*斜体*</code><br><code>**重点**</code><br><code>- list 列表(支持层级)</code><br><code>&gt; hello 引用样式(支持层级)</code><br><code>-[] checkBox 代办</code><br><code>*** 分隔线</code><br><code>--- 分隔线</code><br><code>|   |   |</code><br><code>|-|-|</code><br><code>|   |   |</code><br>表格(各个工具可能有差异，typora支持的好)<code> </code> <code>  代码块` 两行之间 `</code>c++ 根据语法着色`</p>
</blockquote>
<p>更多语法：<br><a href="https://www.jianshu.com/p/b03a8d7b1719">https://www.jianshu.com/p/b03a8d7b1719</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>架构学习的记录</p>
<a id="more"></a>
<h3 id="组件化设计"><a href="#组件化设计" class="headerlink" title="组件化设计"></a>组件化设计</h3><p>1.功能模块，互相解耦，通过中间层调用<br>2.公共组件抽离，统一维护管理<br>3.开发人员只做业务</p>
<p>优点：插件化，业务调整，之间互不影响<br>缺点：公共组件的统一维护可以提高效率，但也存在风险</p>
<h3 id="极端分离设计"><a href="#极端分离设计" class="headerlink" title="极端分离设计"></a>极端分离设计</h3><p>非专业叫法<br>1.所有模块、及其涉及的通用模块完全独立管理，完全解耦<br>2.模块之间 字典数据传递</p>
<p>优点：完全的模块分离<br>缺点：开发成本高，适合大型、多开发团队的App</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>挖坑，持续填坑</p>
<a id="more"></a>

<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>C负责M和V的对象管理和生命周期</li>
<li>M和V完全分离</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>C的业务负担较重</li>
</ul>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul>
<li>MVP+C ，本质还有C的存在</li>
<li>C持有P对象，P弱引用C</li>
<li>P的定位和MVC中的C类似，相当于把C的工作拆分成多个P，每个P负责部分业务功能，</li>
<li>C负责管理P对象管理和生命周期，对P做业务扩展</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul>
<li>MVVM+C   类似MVP，C可以有多个VM</li>
<li>VM持有M对象，持有V的对象</li>
<li>V不引用VM的头文件，只声明类型；和M分离</li>
<li>数据响应不再是VM发起，有V建立观察器去监听变化；<br>  实现方法：kvo，KVOController，RAC</li>
</ul>
<h5 id="优点：-进一步减少了VM的负担"><a href="#优点：-进一步减少了VM的负担" class="headerlink" title="优点： 进一步减少了VM的负担"></a>优点： 进一步减少了VM的负担</h5><p>理解还是片面,待整理<br><a href="https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f">https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f</a><br><a href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm">https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm</a></p>
<h3 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h3>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>快速实现CollectionView的无限轮播器</title>
    <url>/2020/09/15/%E5%AE%9E%E7%8E%B0CollectionView%E7%9A%84%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/600/1*ZYZmgctLW304fZ3UqYheLw.gif" alt="avatar"><br>通过CollectionView快速实现一个无限轮播器,基于原生uikit</p>
<a id="more"></a>

<p>核心逻辑是在collection的dateSource</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> infiniteSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>infiniteSize可以指定一个非常大的值,但不要指定Int.max,会越界崩溃</p>
<p>例如<br><em>let infiniteSize = 100000</em></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func collection<span class="constructor">View(<span class="params">_</span> <span class="params">collectionView</span>: UICollectionView, <span class="params">cellForItemAt</span> <span class="params">indexPath</span>: IndexPath)</span> -&gt; UICollectionViewCell &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = collectionView.dequeue<span class="constructor">ReusableCell(<span class="params">withReuseIdentifier</span>: <span class="string">&quot;ColorCell&quot;</span>, <span class="params">for</span>: <span class="params">indexPath</span>)</span></span><br><span class="line">  guard <span class="keyword">let</span> size = listSize, size &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; return cell&#125;</span><br><span class="line">  cell.backgroundColor = colorList<span class="literal">[<span class="identifier">indexPath</span>.<span class="identifier">row</span> % <span class="identifier">size</span>]</span></span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cell通过对集合取余来控制集合索引<br>写完之后,现在可以实现向右的无限滑动,目前,但是向左还不行</p>
<h4 id="原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果"><a href="#原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果" class="headerlink" title="原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果"></a>原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果</h4><p>向左的思路是把默认的collection的索引指向itemSize的中间值,这样左右都有infiniteSize/2的数量了</p>
<p>可以在viewDidload中加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let size &#x3D; listSize, size &gt; 0 else &#123; return &#125;</span><br><span class="line">let midIndexPath &#x3D; IndexPath(row: infiniteSize &#x2F; size &#x2F; 2 * size, section: 0)</span><br><span class="line">             collectionView.scrollToItem(at: midIndexPath,</span><br><span class="line">                                              at: .centeredHorizontally,</span><br><span class="line">                                        animated: false)</span><br></pre></td></tr></table></figure>

<p>size是数据容器的大小,确保index指向容器的第一个</p>
<p>这样就完成了,方法比较取巧,</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>快速,方便</li>
<li>由于reuseable的cell并不会占用内存资源</li>
<li>原生实现,易于维护</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>伪无限循环,到了infinitySize上限,就滚不动了</li>
</ul>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
  <entry>
    <title>24个好用的Extension让代码更整洁</title>
    <url>/2020/09/21/24%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84Extension%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%95%B4%E6%B4%81/</url>
    <content><![CDATA[<h3 id="24个好用的Extension让代码更整洁-转自Medium"><a href="#24个好用的Extension让代码更整洁-转自Medium" class="headerlink" title="24个好用的Extension让代码更整洁(转自Medium)"></a>24个好用的Extension让代码更整洁(转自Medium)</h3><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/0_HQm1yU37T9Kn0Sqk.jpg" alt="avatar" style="zoom:50%;" />

<p>​    扩展(Extension)是swift和oc最好用的功能之一，能够无侵入的对现有系统类和工程添加新方法</p>
<p>作为一个iOS和Android的双料开发者，我经常能看到Android代码的功能方法更简洁，易懂；</p>
<p>当然通过扩展，我们也可以把这些特性使用在swift上，使swift项目也更精炼，更加好用</p>
<p>​    以下代码是基于swift，但其实对于oc，大部分也可以很容易的移植</p>
<a id="more"></a>



<h4 id="1-String-trim-and-Swift-trimmed"><a href="#1-String-trim-and-Swift-trimmed" class="headerlink" title="1.String.trim() and Swift.trimmed"></a>1.String.trim() and Swift.trimmed</h4><p>​    我们经常会用到string的trim功能，帮助把string里的空格，制表符，换行符等特殊符号去掉</p>
<p>扩展可以这么写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> trimmed: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">trim</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span>.trimmed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> str<span class="number">1</span> = <span class="string">&quot;  a b c d e   \n&quot;</span></span><br><span class="line"><span class="attribute">var</span> str<span class="number">2</span> = str<span class="number">1</span>.trimmed</span><br><span class="line"><span class="attribute">str1</span>.trim()</span><br></pre></td></tr></table></figure>



<h4 id="2-Int-toDouble-and-Double-toInt"><a href="#2-Int-toDouble-and-Double-toInt" class="headerlink" title="2. Int.toDouble() and Double.toInt()"></a>2. Int.toDouble() and Double.toInt()</h4><p>​    Int和Double,CGFloat的转换是项目中经常会用到.但实际使用上遇到Double(a),必须要求a是非可选类型,所以经常要做额外处理</p>
<p>可以对Int和Double的扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toDouble</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="type">Double</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toInt</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="type">Int</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">15.78</span></span><br><span class="line"><span class="keyword">let</span> b = a.toInt()</span><br></pre></td></tr></table></figure>



<h4 id="3-String-toDate-…-and-Date-toString-…"><a href="#3-String-toDate-…-and-Date-toString-…" class="headerlink" title="3. String.toDate(…) and Date.toString(…)"></a>3. String.toDate(…) and Date.toString(…)</h4><p>​    对Date和String的转换做易用的封装</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toDate</span><span class="params">(format: String)</span></span> -&gt; <span class="type">Date?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</span><br><span class="line">        df.dateFormat = format</span><br><span class="line">        <span class="keyword">return</span> df.date(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(format: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</span><br><span class="line">        df.dateFormat = format</span><br><span class="line">        <span class="keyword">return</span> df.string(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strDate = <span class="string">&quot;2020-08-10 15:00:00&quot;</span></span><br><span class="line"><span class="keyword">let</span> date = strDate.toDate(format: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> strDate2 = date?.<span class="built_in">toString</span>(format: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>​    </p>
<h4 id="4-Int-fenToYuan"><a href="#4-Int-fenToYuan" class="headerlink" title="4.Int.fenToYuan()"></a>4.Int.fenToYuan()</h4><p>​    没什么可说的,金额的分转元</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fenToYuan</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="type">Double</span>(<span class="keyword">self</span>) / <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fen = <span class="number">12350</span></span><br><span class="line"><span class="keyword">let</span> yuan = fen.fenToYuan()</span><br></pre></td></tr></table></figure>





<h4 id="5-String-asCoordinates"><a href="#5-String-asCoordinates" class="headerlink" title="5.String.asCoordinates()"></a>5.String.asCoordinates()</h4><p>​    string转成坐标,包括两个值,精度和纬度,在3D场景下还有高度数据,高度不是很常用</p>
<p>我们根据string里的逗号来解析,转成CLLocationCoordinate2D对象</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asCoordinates: <span class="type">CLLocationCoordinate2D?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> components = <span class="keyword">self</span>.components(separatedBy: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> components.<span class="built_in">count</span> != <span class="number">2</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> strLat = components[<span class="number">0</span>].trimmed</span><br><span class="line">        <span class="keyword">let</span> strLng = components[<span class="number">1</span>].trimmed</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dLat = <span class="type">Double</span>(strLat),</span><br><span class="line">            <span class="keyword">let</span> dLng = <span class="type">Double</span>(strLng) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: dLat, longitude: dLng)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strCoordinates = <span class="string">&quot;41.6168, 41.6367&quot;</span></span><br><span class="line"><span class="keyword">let</span> coordinates = strCoordinates.asCoordinates</span><br></pre></td></tr></table></figure>



<h4 id="6-String-asURL"><a href="#6-String-asURL" class="headerlink" title="6.String.asURL()"></a>6.String.asURL()</h4><p>​    URL是用处理链接的常用类,很灵活,可以连接不同组建,可以把各种类型处理为URLs,同时,也经常会配合着string的使用</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asURL: <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="type">URL</span>(string: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strUrl = <span class="string">&quot;https://medium.com&quot;</span></span><br><span class="line"><span class="keyword">let</span> url = strUrl.asURL</span><br></pre></td></tr></table></figure>



<h4 id="7-UIDevice-vibrate"><a href="#7-UIDevice-vibrate" class="headerlink" title="7.UIDevice.vibrate()"></a>7.UIDevice.vibrate()</h4><p>​    iPhone的震动效果是手机行业内做的最好的,可以主动调用这个</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AudioToolbox</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIDevice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">vibrate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1519</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.vibrate()</span><br></pre></td></tr></table></figure>





<h4 id="8-String-width-…-and-String-height-…"><a href="#8-String-width-…-and-String-height-…" class="headerlink" title="8.String.width(…) and String.height(…)"></a>8.String.width(…) and String.height(…)</h4><p>​    计算UILabel里的text占用的宽度,根据Font计算</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(withConstrainedWidth width: CGFloat, font: UIFont)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: width, height: .greatestFiniteMagnitude)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = <span class="keyword">self</span>.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [.font: font], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">width</span><span class="params">(withConstrainedHeight height: CGFloat, font: UIFont)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: .greatestFiniteMagnitude, height: height)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = <span class="keyword">self</span>.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [.font: font], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSAttributedString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(withConstrainedWidth width: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: width, height: .greatestFiniteMagnitude)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">width</span><span class="params">(withConstrainedHeight height: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> constraintRect = <span class="type">CGSize</span>(width: .greatestFiniteMagnitude, height: height)</span><br><span class="line">        <span class="keyword">let</span> boundingBox = boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ceil(boundingBox.width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> textHeight = text.height(withConstrainedWidth: <span class="number">100</span>, font: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>))</span><br></pre></td></tr></table></figure>



<h4 id="9-String-containsOnlyDigits"><a href="#9-String-containsOnlyDigits" class="headerlink" title="9.String.containsOnlyDigits"></a>9.String.containsOnlyDigits</h4><p>​    检查string是否只含有数字</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> containsOnlyDigits: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> notDigits = <span class="type">NSCharacterSet</span>.decimalDigits.inverted</span><br><span class="line">        <span class="keyword">return</span> rangeOfCharacter(from: notDigits, options: <span class="type">String</span>.<span class="type">CompareOptions</span>.literal, range: <span class="literal">nil</span>) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> digitsOnlyYes = <span class="string">&quot;1234567890&quot;</span>.containsOnlyDigits</span><br><span class="line"><span class="keyword">let</span> digitsOnlyNo = <span class="string">&quot;12345+789&quot;</span>.containsOnlyDigits</span><br></pre></td></tr></table></figure>



<h4 id="10-String-isAlphanumeric"><a href="#10-String-isAlphanumeric" class="headerlink" title="10.String.isAlphanumeric"></a>10.String.isAlphanumeric</h4><p>​    检查string是否只有数字和大小写字母,经常用于密码格式验证</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isAlphanumeric: <span class="type">Bool</span> &#123;</span><br><span class="line">        !isEmpty &amp;&amp; range(of: <span class="string">&quot;[^a-zA-Z0-9]&quot;</span>, options: .regularExpression) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alphanumericYes = <span class="string">&quot;asd3kJh43saf&quot;</span>.isAlphanumeric</span><br><span class="line"><span class="keyword">let</span> alphanumericNo = <span class="string">&quot;Kkncs+_s3mM.&quot;</span>.isAlphanumeric</span><br></pre></td></tr></table></figure>





<h3 id="11-String-下标"><a href="#11-String-下标" class="headerlink" title="11.String 下标"></a>11.String 下标</h3><p>​    swift的截取内容是比较繁琐的,比如:获取第n位内容,可以只设置一个Int参数</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span> (i: <span class="type">Int</span>) -&gt; <span class="type">Character</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[index(startIndex, offsetBy: i)]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountableRange</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start..&lt;end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountableClosedRange</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">CountablePartialRangeFrom</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = index(startIndex, offsetBy: bounds.lowerBound)</span><br><span class="line">        <span class="keyword">let</span> end = index(endIndex, offsetBy: -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> end &lt; start &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[start...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">PartialRangeThrough</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; startIndex &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[startIndex...end]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span> (bounds: <span class="type">PartialRangeUpTo</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> end = index(startIndex, offsetBy: bounds.upperBound)</span><br><span class="line">        <span class="keyword">if</span> end &lt; startIndex &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[startIndex..&lt;end]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscript1 = <span class="string">&quot;Hello, world!&quot;</span>[<span class="number">7</span>...]</span><br><span class="line"><span class="keyword">let</span> subscript2 = <span class="string">&quot;Hello, world!&quot;</span>[<span class="number">7</span>...<span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<h4 id="12-UIImage-squared"><a href="#12-UIImage-squared" class="headerlink" title="12. UIImage.squared"></a>12. UIImage.squared</h4><p>​    如果需要用户提交一张方形照片,他们很少有标准的方形照片,但一般App里的头像控件往往都是圆形或者方形的</p>
<p>这个扩展可以快速的做处理</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> squared: <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originalWidth  = size.width</span><br><span class="line">        <span class="keyword">let</span> originalHeight = size.height</span><br><span class="line">        <span class="keyword">var</span> x: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">var</span> edge: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (originalWidth &gt; originalHeight) &#123;</span><br><span class="line">            <span class="comment">// landscape</span></span><br><span class="line">            edge = originalHeight</span><br><span class="line">            x = (originalWidth - edge) / <span class="number">2.0</span></span><br><span class="line">            y = <span class="number">0.0</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originalHeight &gt; originalWidth) &#123;</span><br><span class="line">            <span class="comment">// portrait</span></span><br><span class="line">            edge = originalWidth</span><br><span class="line">            x = <span class="number">0.0</span></span><br><span class="line">            y = (originalHeight - originalWidth) / <span class="number">2.0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// square</span></span><br><span class="line">            edge = originalWidth</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cropSquare = <span class="type">CGRect</span>(x: x, y: y, width: edge, height: edge)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> imageRef = cgImage?.cropping(to: cropSquare) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: imageRef, scale: scale, orientation: imageOrientation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    以上是类方法,也可以改为成实例方法</p>
<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> imgSquared = img.squared <span class="comment">// img.squared() for method</span></span><br></pre></td></tr></table></figure>

<h4 id="13-UIImage-resized-…"><a href="#13-UIImage-resized-…" class="headerlink" title="13.UIImage.resized(…)"></a>13.UIImage.resized(…)</h4><p>​    图片资源上传服务器的时候,会有大小限制,往往会处理成一张小尺寸照片</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">resized</span><span class="params">(maxSize: CGFloat)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> scale: <span class="type">CGFloat</span></span><br><span class="line">        <span class="keyword">if</span> size.width &gt; size.height &#123;</span><br><span class="line">            scale = maxSize / size.width</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            scale = maxSize / size.height</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> newWidth = size.width * scale</span><br><span class="line">        <span class="keyword">let</span> newHeight = size.height * scale</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(<span class="type">CGSize</span>(width: newWidth, height: newHeight))</span><br><span class="line">        draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: newWidth, height: newHeight))</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> newImage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img2 = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> img2Thumb = img2.resized(maxSize: <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<p>可以结合第12条一起使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="type">UIImage</span>() <span class="comment">// Must be a real UIImage</span></span><br><span class="line"><span class="keyword">let</span> imgPrepared = img.squared?.resized(maxSize: <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<h4 id="14-Int-toString"><a href="#14-Int-toString" class="headerlink" title="14.Int.toString()"></a>14.Int.toString()</h4><p>​    一般可以用”‘\(num)”的方法把Int类型转为string,但是有个问题,如果你的num是可选类型,则会把”optional”也加进去,Kotlin处理可选类型比较优雅:对任意类型someVar?.toString,返回可选string</p>
<p>​    可惜,swift不允许对Any扩展,但至少可以给Int加上</p>
<p>扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;\(self)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i1 = <span class="number">15</span></span><br><span class="line"><span class="keyword">let</span> i1AsString = i1.<span class="built_in">toString</span>()</span><br></pre></td></tr></table></figure>

<h4 id="15-Double-toString"><a href="#15-Double-toString" class="headerlink" title="15.Double.toString()"></a>15.Double.toString()</h4><p>​    和14同理,对Double加toString方法,但限制是保留两位小数</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>(format: <span class="string">&quot;%.02f&quot;</span>, <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d1 = <span class="number">15.67</span></span><br><span class="line"><span class="keyword">let</span> d1AsString = d1.<span class="built_in">toString</span>()</span><br></pre></td></tr></table></figure>



<h4 id="16-Double-toPrice"><a href="#16-Double-toPrice" class="headerlink" title="16.Double.toPrice()"></a>16.Double.toPrice()</h4><p>​    用的地方不多,转成”323,232,21.33$”这种格式</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toPrice</span><span class="params">(currency: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> nf = <span class="type">NumberFormatter</span>()</span><br><span class="line">        nf.decimalSeparator = <span class="string">&quot;,&quot;</span></span><br><span class="line">        nf.groupingSeparator = <span class="string">&quot;.&quot;</span></span><br><span class="line">        nf.groupingSize = <span class="number">3</span></span><br><span class="line">        nf.usesGroupingSeparator = <span class="literal">true</span></span><br><span class="line">        nf.minimumFractionDigits = <span class="number">2</span></span><br><span class="line">        nf.maximumFractionDigits = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (nf.string(from: <span class="type">NSNumber</span>(value: <span class="keyword">self</span>)) ?? <span class="string">&quot;?&quot;</span>) + currency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dPrice = <span class="number">16.50</span></span><br><span class="line"><span class="keyword">let</span> strPrice = dPrice.toPrice(currency: <span class="string">&quot;€&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="17-String-asDict"><a href="#17-String-asDict" class="headerlink" title="17.String.asDict"></a>17.String.asDict</h4><p>​    把JSON格式的string拆成字典,swift很方便</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asDict: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&quot;&#123;\&quot;hello\&quot;: \&quot;world\&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">let</span> dictFromJson = json.asDict</span><br></pre></td></tr></table></figure>

<h4 id="18-String-asArray"><a href="#18-String-asArray" class="headerlink" title="18.String.asArray"></a>18.String.asArray</h4><p>​    和上个类似,转成集合类型</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asArray: [<span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments) <span class="keyword">as</span>? [<span class="type">Any</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json2 = <span class="string">&quot;[1, 2, 3]&quot;</span></span><br><span class="line"><span class="keyword">let</span> arrFromJson2 = json2.asArray</span><br></pre></td></tr></table></figure>



<h4 id="19-String-asAttributedString"><a href="#19-String-asAttributedString" class="headerlink" title="19.String.asAttributedString"></a>19.String.asAttributedString</h4><p>​    有时我们需要一些跨平台的文本格式,最常用的是HTML格式,UILabel可以对粗体<strong>,下划线等要是做处理.把HTML格式转成NSAttributedString格式,然后给UILabel.attributedText赋值使用</p>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asAttributedString: <span class="type">NSAttributedString?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>? <span class="type">NSAttributedString</span>(data: data, options: [.documentType: <span class="type">NSAttributedString</span>.<span class="type">DocumentType</span>.html], documentAttributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> htmlString = <span class="string">&quot;&lt;p&gt;Hello, &lt;strong&gt;world!&lt;/string&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> attrString = htmlString.asAttributedString</span><br></pre></td></tr></table></figure>



<h4 id="20-Bundle-appVersion"><a href="#20-Bundle-appVersion" class="headerlink" title="20.Bundle.appVersion"></a>20.Bundle.appVersion</h4><p>​    可以从Info.plist里加载app的版本信息,用途有:</p>
<ul>
<li>获取版本信息</li>
<li>检查是否有更新</li>
<li>展示版本信息</li>
<li>支持邮件里包含版本信息</li>
</ul>
<p>扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> appVersion: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.infoDictionary?[<span class="string">&quot;CFBundleShortVersionString&quot;</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> mainAppVersion: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span>.main.appVersion</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> appVersion = <span class="type">Bundle</span>.mainAppVersion</span><br></pre></td></tr></table></figure>





<p>原文:</p>
<blockquote>
<p><a href="https://medium.com/better-programming/24-swift-extensions-for-cleaner-code-41e250c9c4c3">https://medium.com/better-programming/24-swift-extensions-for-cleaner-code-41e250c9c4c3</a></p>
</blockquote>
<h3 id="原文确实只有20个…"><a href="#原文确实只有20个…" class="headerlink" title="原文确实只有20个…"></a>原文确实只有20个…</h3>]]></content>
      <tags>
        <tag>效率</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(下)</title>
    <url>/2020/09/09/Effective-oc-%E7%AC%94%E8%AE%B0(%E4%B8%8B)/</url>
    <content><![CDATA[<p>6、7章<br>Block和GCD 37-46<br>系统框架 47-52</p>
<a id="more"></a>
<h3 id="37-理解Block"><a href="#37-理解Block" class="headerlink" title="37.理解Block"></a>37.理解Block</h3><ul>
<li>block在定义范围有效；栈block的生命周期，括号范围内</li>
<li>堆block，生命周期被管理</li>
</ul>
<h3 id="38-typedef-常用Block"><a href="#38-typedef-常用Block" class="headerlink" title="38.typedef 常用Block"></a>38.typedef 常用Block</h3><ul>
<li>typdef void(^DKBLock)(void *);</li>
<li>好处 修改方便、易读</li>
<li>建议根据使用场景，同类型block 声明为不同name</li>
</ul>
<h3 id="39-Block的好处"><a href="#39-Block的好处" class="headerlink" title="39.Block的好处"></a>39.Block的好处</h3><ul>
<li>delegate的缺点、如果包含多个委托，同一个函数要区分</li>
<li>block更集中，易维护、易读</li>
<li>建议多个参数，整理为一个handler，参数之间可以配合使用</li>
</ul>
<h3 id="40-块里的循环引用问题"><a href="#40-块里的循环引用问题" class="headerlink" title="40.块里的循环引用问题"></a>40.块里的循环引用问题</h3><ul>
<li>主动打破 块里将block对象释放（不执行就会有问题）</li>
<li>block持有者 使用完处理掉</li>
</ul>
<h3 id="41-多用派发队列，少用锁"><a href="#41-多用派发队列，少用锁" class="headerlink" title="41.多用派发队列，少用锁"></a>41.多用派发队列，少用锁</h3><ul>
<li>多个synchronized(self),共享锁，不推荐</li>
<li>异步调用设置方法，由于涉及拷贝块，衡量下拷贝和执行的速度</li>
</ul>
<h3 id="42-多用GCD，少用performSelector"><a href="#42-多用GCD，少用performSelector" class="headerlink" title="42.多用GCD，少用performSelector"></a>42.多用GCD，少用performSelector</h3><ul>
<li>performSelector局限多，参数支持最多2个</li>
<li>performSelector返回值限定id，基础类型需要做转换；返回值是c语言结构体就不建议用</li>
</ul>
<h3 id="43-GCD和NSOperation"><a href="#43-GCD和NSOperation" class="headerlink" title="43.GCD和NSOperation"></a>43.GCD和NSOperation</h3><ul>
<li>dispatch_once 执行一次；单例</li>
<li>NSOperation：可以取消、依赖、kvo观察任务状态</li>
</ul>
<h3 id="44-Dispatch-Group"><a href="#44-Dispatch-Group" class="headerlink" title="44.Dispatch Group"></a>44.Dispatch Group</h3><ul>
<li>dispatch_group_wait 阻塞等待完成执行</li>
<li>dispatch_group_notify 非阻塞等待完成</li>
<li>dispatch_apply </li>
</ul>
<h3 id="45-dispatch-once"><a href="#45-dispatch-once" class="headerlink" title="45.dispatch_once"></a>45.dispatch_once</h3><p>标准推荐写法</p>
<blockquote>
<p>static Class *instance = nil;<br>static dispatch_group_t token;<br>dispatch_once {&amp;token, ^{ instance = [[Class alloc]init]}}<br>return instance;</p>
</blockquote>
<ul>
<li>比synchronized快</li>
</ul>
<h3 id="46-不要使用dispatch-get-current-queue"><a href="#46-不要使用dispatch-get-current-queue" class="headerlink" title="46.不要使用dispatch_get_current_queue"></a>46.不要使用dispatch_get_current_queue</h3><h1 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h1><h3 id="47"><a href="#47" class="headerlink" title="47."></a>47.</h3>]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift下实现方法交换method swizzle(转自Medium)</title>
    <url>/2020/09/30/Swift%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2method%20swizzle/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/20200930102055.png"></p>
<p>方法交换是oc的技术,可以借助runtime的动态派发的特性实现两个方法的实现部分互换;</p>
<p>那么在swift如果实现呢?</p>
<a id="more"></a>

<p>在我们深入挖掘实现细节之前,需要对<code>selectors</code>相关的概念做一些说明</p>
<h4 id="什么是selectors"><a href="#什么是selectors" class="headerlink" title="什么是selectors"></a>什么是selectors</h4><p><code>selector</code>表示的一个类对象的方法的名称,<code>selector</code>没有具体实现,不做任何事情,唯一的目标的就是标识一个方法</p>
<h4 id="为什么使用方法交换-method-swizzling"><a href="#为什么使用方法交换-method-swizzling" class="headerlink" title="为什么使用方法交换(method swizzling)"></a>为什么使用方法交换(method swizzling)</h4><p>有以下场景可以用到:</p>
<p>方便的在App监测一个<code>ViewController</code>到另一个<code>ViewController</code>的切换;</p>
<p>具体方法是修改<code>viewWillAppear</code>的<code>selector,添加一些监控行为</code></p>
<p>实现如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">_swizzled_viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">	_swizzled_viewWillAppear(animated)</span><br><span class="line">	<span class="comment">//你要监控的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>@objc</code>说明用到oc的特性方法</p>
</li>
<li><p><code>dynamic</code>说明用到了动态</p>
</li>
<li><p>这不是会循环调用么?为什么要调用自己? 不会,因为切换后内括号内的调用其实是调用了原有的<code>ViewWillAppear</code></p>
</li>
</ul>
<p>通过<code>method_exchangeImplementations</code>方法,实现两个方法的交换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selector1 = #selector(<span class="type">UIViewController</span>.viewWillAppear(<span class="number">_</span>:))</span><br><span class="line"><span class="keyword">let</span> selector2 = #selector(<span class="type">UIViewController</span>.swizzled_viewWillAppear(:))</span><br><span class="line"><span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector1)!</span><br><span class="line"><span class="keyword">let</span> swizzleMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector2)!</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzleMethod)</span><br></pre></td></tr></table></figure>



<p>前面的实现整理到一起就完成了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">_swizzled_viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        _swizzled_viewWillAppear(animated)</span><br><span class="line">	<span class="comment">//你要监控的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">swizzleViewWillAppear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> selector1 = #selector(<span class="type">UIViewController</span>.viewWillAppear(<span class="number">_</span>:))</span><br><span class="line">        <span class="keyword">let</span> selector2 = #selector(<span class="type">UIViewController</span>._swizzled_viewWillAppear(<span class="number">_</span>:))</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector1)!</span><br><span class="line">        <span class="keyword">let</span> swizzleMethod = class_getInstanceMethod(<span class="type">UIViewController</span>.<span class="keyword">self</span>, selector2)!</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>别忘了调用方法交换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIViewController</span>.swizzleViewWillAppear()</span><br></pre></td></tr></table></figure>

<p>现在,<code>UIViewController</code>的所有实例和子类实例调用viewWillAppear时,都会触发<code> _swizzled_viewWillAppear</code></p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><p>有两点要注意:</p>
<ul>
<li><p>如果你要实现方法交换,你的类必须继承自<code>NSObject</code></p>
</li>
<li><p>你要交换的方法必须具有动态属性<code>@objc dynamic</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(上)</title>
    <url>/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0(%E4%B8%8A)/</url>
    <content><![CDATA[<p>前五章内容：<br>熟悉oc 1-5<br>对象、消息、runtime 6-14<br>接口与API 15-22<br>协议与分类 23-28<br>内存管理 29-36</p>
<a id="more"></a>
<h3 id="1-oc起源"><a href="#1-oc起源" class="headerlink" title="1.oc起源"></a>1.oc起源</h3><h3 id="2-减少头文件引用"><a href="#2-减少头文件引用" class="headerlink" title="2.减少头文件引用"></a>2.减少头文件引用</h3><ul>
<li>如果不使用类方法可以仅声明@class Class 即可</li>
</ul>
<h3 id="3-多用字面量"><a href="#3-多用字面量" class="headerlink" title="3.多用字面量"></a>3.多用字面量</h3><ul>
<li>代码整洁、直观</li>
<li>NSArray arrayWithObject：遇到nil不会崩溃，内部会判断</li>
</ul>
<h3 id="4-少用define"><a href="#4-少用define" class="headerlink" title="4.少用define"></a>4.少用define</h3><ul>
<li>建议使用const来替代：<ol>
<li>可以加static 控制作用域、避免冲突</li>
<li>类型含义明确，维护性好</li>
<li>static 编译器会自行优化为define</li>
</ol>
</li>
</ul>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><ul>
<li>占用1字节</li>
<li>type NS_ENUM oc枚举<ol>
<li>根据编译平台决定使用新、旧协议(c++)</li>
<li>新协议指的是底层数据类型存储</li>
<li>switch 处理enum分支；尽量不用default，覆盖每一个分支，避免新增enum，switch未处理的情况</li>
</ol>
</li>
</ul>
<h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><ul>
<li>类对象保管存储偏移量</li>
<li>@dynamic 配合CoreData动态添加方法</li>
</ul>
<h3 id="7-对象内部使用实例变量"><a href="#7-对象内部使用实例变量" class="headerlink" title="7.对象内部使用实例变量"></a>7.对象内部使用实例变量</h3><ul>
<li><p>self.var 语法</p>
<ol>
<li>效率低</li>
<li>可触发kvo，可使用懒加载</li>
</ol>
</li>
<li><p><code>_var</code> 语法</p>
<ol>
<li>不触发kvo</li>
<li>getter语法里使用</li>
</ol>
</li>
<li><p>折中方案</p>
<ol>
<li>写入用setter</li>
<li>读取用_var</li>
</ol>
</li>
</ul>
<h3 id="8-对象等同性"><a href="#8-对象等同性" class="headerlink" title="8.对象等同性"></a>8.对象等同性</h3><ul>
<li>isEqualToString比isEqual快</li>
<li>== 判断指针操作</li>
<li>hash()方法用于比较，自己实现；注意set时 的hash 碰撞问题</li>
<li>结构对象使用主键比较</li>
</ul>
<h3 id="9-类簇"><a href="#9-类簇" class="headerlink" title="9.类簇"></a>9.类簇</h3><ul>
<li>oc没有概念上的抽象类，oc的抽象类不写init</li>
<li>类簇类似抽象类的概念，提供接口，不提供实现</li>
<li>NSArray 里面是工厂，NSArray class 隐藏 无法通过实例访问<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[arr <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[str <span class="keyword">class</span>], [<span class="built_in">NSString</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">///分别打印</span></span><br><span class="line">__NSArray0|<span class="built_in">NSArray</span></span><br><span class="line">__NSCFConstantString|<span class="built_in">NSString</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-动态添加属性"><a href="#10-动态添加属性" class="headerlink" title="10.动态添加属性"></a>10.动态添加属性</h3><ul>
<li>本质是全局创建Map，以Class为key的外部表</li>
<li>示例：UIAlertView存在多个，通过此方法区分每个；不建议这么用；不好定位异常</li>
</ul>
<h3 id="11-消息派发"><a href="#11-消息派发" class="headerlink" title="11.消息派发"></a>11.消息派发</h3><ul>
<li>objc_msg_send 有两个隐藏参数 (id,SEL)</li>
<li>runtime</li>
<li>尾调用优化：去掉函数栈帧，优化</li>
</ul>
<h3 id="12-消息转发"><a href="#12-消息转发" class="headerlink" title="12.消息转发"></a>12.消息转发</h3><ul>
<li>resolveInstanceMethod/resolveClassMethod<ol>
<li>配合@dynamic</li>
</ol>
</li>
<li>备用接受者 forwardingTargetForSelector<ol>
<li>返回接收对象</li>
<li>1对1</li>
<li>快速</li>
</ol>
</li>
<li>完成消息转发forwardInvocation<ol>
<li>修改方法内容</li>
<li>1对多</li>
<li>慢</li>
</ol>
</li>
</ul>
<h3 id="13-方法交换"><a href="#13-方法交换" class="headerlink" title="13.方法交换"></a>13.方法交换</h3><ul>
<li>用于调试目的<ol>
<li>用户行为监控</li>
<li>调试异常</li>
<li>一般应用层不建议使用</li>
</ol>
</li>
</ul>
<h3 id="14-类对象意义"><a href="#14-类对象意义" class="headerlink" title="14.类对象意义"></a>14.类对象意义</h3><ul>
<li>判断对象关系 isKindOf isMemberOf；</li>
<li>示例：NSProxy 对于isKinfOf 对 class处理可能不一样(消息转发)</li>
<li>消息传递机制的前提</li>
</ul>
<h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul>
<li>c函数需要加前缀</li>
<li>lib对象，自己引用的第三方加前缀</li>
</ul>
<h3 id="16-全能初始化器"><a href="#16-全能初始化器" class="headerlink" title="16.全能初始化器"></a>16.全能初始化器</h3><ul>
<li><p>和swift的指定初始化器类似，swift 强制性 oc 没有这种约束 designted翻译差异。</p>
</li>
<li><p>中文翻译的怪怪的；<br> 我的翻译是：<br> <strong>目标是为了实例的初始化能保证类和其父类的所有成员得到初始化</strong></p>
<ol>
<li>全能初始化器的作用是为了保证当前类成员得到初始化</li>
<li>非全能初始化器应调用当前类全能初始化器</li>
<li>子类的全能初始化器必须调用父类的全能初始化器</li>
<li>如果父类的全能初始化器，子类没有实现，那么实例可以直接调用父类的全能初始化器初始化，子类成员变量没有初始化。为了解决这个问题，要么 抛异常，要么 重写父类的全能初始化器</li>
</ol>
<p> <strong>这块swift做成了编译检查，而且swift官方文档描述的更清楚</strong></p>
</li>
</ul>
<h3 id="17-实现descripion方法"><a href="#17-实现descripion方法" class="headerlink" title="17.实现descripion方法"></a>17.实现descripion方法</h3><ul>
<li>自己实现的建议加上类名称和对象地址</li>
<li>lldb里po 打印的是debugDescripion</li>
</ul>
<h3 id="18-使用不可变对象"><a href="#18-使用不可变对象" class="headerlink" title="18.使用不可变对象"></a>18.使用不可变对象</h3><ul>
<li>涉及到扩展的作用外部ro，内部rw可以点语法修改</li>
<li>成员变量对外不可变，修改交给类内部</li>
</ul>
<h3 id="19-命名方式"><a href="#19-命名方式" class="headerlink" title="19.命名方式"></a>19.命名方式</h3><h3 id="20-为私有方法加前缀"><a href="#20-为私有方法加前缀" class="headerlink" title="20.为私有方法加前缀"></a>20.为私有方法加前缀</h3><ul>
<li>oc由于动态机制，没有所谓的private函数</li>
<li>不要用_作为前缀，和苹果自带的冲突</li>
</ul>
<h3 id="21-oc错误类型"><a href="#21-oc错误类型" class="headerlink" title="21.oc错误类型"></a>21.oc错误类型</h3><ul>
<li>使用抽象类建议抛出异常</li>
<li>NSError** 使用</li>
</ul>
<h3 id="22-NSCopying协议"><a href="#22-NSCopying协议" class="headerlink" title="22.NSCopying协议"></a>22.NSCopying协议</h3><ul>
<li>copy方法调用copyWithZone；注意重写的应是copyWithZone</li>
</ul>
<h3 id="23-delegate对象间通信"><a href="#23-delegate对象间通信" class="headerlink" title="23.delegate对象间通信"></a>23.delegate对象间通信</h3><ul>
<li>delegate属性weak</li>
<li>自定义代理调用需要判断是否实现方法</li>
<li>位域代替responseToselector</li>
</ul>
<h3 id="24-类拆分成多个分类"><a href="#24-类拆分成多个分类" class="headerlink" title="24.类拆分成多个分类"></a>24.类拆分成多个分类</h3><ul>
<li>方便管理类</li>
<li>函数调用栈里可以看到分类信息</li>
</ul>
<h3 id="25-分类方法加前缀"><a href="#25-分类方法加前缀" class="headerlink" title="25.分类方法加前缀"></a>25.分类方法加前缀</h3><ul>
<li>分类加前缀</li>
<li>分类方法加前缀</li>
</ul>
<h3 id="26-分类中不能添加属性"><a href="#26-分类中不能添加属性" class="headerlink" title="26.分类中不能添加属性"></a>26.分类中不能添加属性</h3><ul>
<li>可以通过同名函数做到模拟属性的效果 不推荐</li>
<li>关联值添加属性 不推荐<br>感觉翻译的还是有点问题<br>原文：<em>“你可能通过属性特质修改了某个属性的管理语义”</em><br>理解：如果要给一个类批量修改属性@property，一般只记得在主类的头文件修改；如果设置了关联值，很可能忘记修改，维护性差</li>
</ul>
<h3 id="27-匿名分类隐藏实现细节"><a href="#27-匿名分类隐藏实现细节" class="headerlink" title="27.匿名分类隐藏实现细节"></a>27.匿名分类隐藏实现细节</h3><ul>
<li>和c++混编时，c++对象放到匿名分类里，避免重复引用头文件造成</li>
<li>修改ro属性，内部为rw</li>
<li>隐藏遵守的协议</li>
<li>私有属性，没在.h里，一般看不到；私有变量和放在impl里作用相同</li>
</ul>
<h3 id="28-协议实现匿名函数"><a href="#28-协议实现匿名函数" class="headerlink" title="28.协议实现匿名函数"></a>28.协议实现匿名函数</h3><ul>
<li>pop面向协议编程</li>
<li>隐藏实现，仅暴露协议内容</li>
</ul>
<h3 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h3><ul>
<li>retainCount 不推荐；因为如果autorelease了retainCount值不准确</li>
<li>mrc return [对象 autorelease],避免调用者不释放</li>
</ul>
<h3 id="30-ARC简化引用计数"><a href="#30-ARC简化引用计数" class="headerlink" title="30.ARC简化引用计数"></a>30.ARC简化引用计数</h3><ul>
<li>autorelease 后的返回函数 接收强类型对象 编译会自动retain</li>
<li>不能复写release函数</li>
<li>CF对象自行释放</li>
</ul>
<h3 id="31-dealloc作用"><a href="#31-dealloc作用" class="headerlink" title="31.dealloc作用"></a>31.dealloc作用</h3><ul>
<li>不要调用存取方法</li>
<li>可能并不会触发、在应用异常退出；可以在ApplicationWillTerminate里释放</li>
<li>某些文件句柄、socket系统映射文件，不要直接释放、调用相应close方法</li>
<li>释放c对象</li>
<li>释放通知、kvo</li>
<li></li>
</ul>
<h3 id="32-捕获异常"><a href="#32-捕获异常" class="headerlink" title="32.捕获异常"></a>32.捕获异常</h3><ul>
<li>arc 下不建议 try catch ，加很多辅助代码</li>
<li>如果objc++ 可以处理try catch</li>
</ul>
<h3 id="33-弱引用避免循环引用"><a href="#33-弱引用避免循环引用" class="headerlink" title="33.弱引用避免循环引用"></a>33.弱引用避免循环引用</h3><ul>
<li>weak属性 避免出现引用闭环</li>
</ul>
<h3 id="34-自动释放块"><a href="#34-自动释放块" class="headerlink" title="34.自动释放块"></a>34.自动释放块</h3><ul>
<li>可以在循环中创建对象使用，控制内存</li>
</ul>
<h3 id="35-僵尸对象调试"><a href="#35-僵尸对象调试" class="headerlink" title="35.僵尸对象调试"></a>35.僵尸对象调试</h3><ul>
<li>打开编译开关</li>
<li>原理：生成僵尸子类，由僵尸子类处理消息</li>
</ul>
<h3 id="36-retainCount"><a href="#36-retainCount" class="headerlink" title="36.retainCount"></a>36.retainCount</h3><ul>
<li>不建议用</li>
<li>由于autorelease，某一个时刻不代表真实值</li>
<li>优化原因，可能永远不为0</li>
<li>常量区对象也会有retainCount值，int.max</li>
</ul>
]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>frame 和 bounds</title>
    <url>/2020/09/11/frame%E5%92%8Cbounds%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="概念上frame以parentView为基准-bonuds以自己为基准"><a href="#概念上frame以parentView为基准-bonuds以自己为基准" class="headerlink" title="概念上frame以parentView为基准,bonuds以自己为基准"></a>概念上frame以parentView为基准,bonuds以自己为基准</h5><a id="more"></a>
<h3 id="在正常的情况下-非transform"><a href="#在正常的情况下-非transform" class="headerlink" title="在正常的情况下(非transform)"></a>在正常的情况下(非transform)</h3><p><strong>调整size</strong><br>1.frame和bonuds的size一样<br>2.调整view的frame的size,bonuds也会跟着改<br>3.调整bonuds的size,bonuds会以view的中心点固定调整,frame的size同步,但origin的坐标会根据发生变化.<br>例如bonuds的width由200变为160,变化值40,frame的origin.x 会 +20</p>
<p><strong>调整origin</strong><br>1.调整frame的origin,位置发生变化,bonuds的origin不变<br>2.调整bounds的origin(很少调整),位置发生绝对值变化,frame得origin跟着同步;特殊的是,如果有subView,<br>subView的绝对位置没变,不跟着父view调整</p>
<h3 id="transform下"><a href="#transform下" class="headerlink" title="transform下"></a>transform下</h3><p>1.bounds不变<br>2.frame是包含view的最小正方形</p>
<p>文字描述,不好理解<br>详细 参考<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603">https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603</a></p>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
  <entry>
    <title>当App启动时,发生了什么(转自Medium)</title>
    <url>/2020/09/15/%E5%BD%93App%E5%90%AF%E5%8A%A8%E6%97%B6,%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88(%E8%BD%AC%E8%87%AAMedium)/</url>
    <content><![CDATA[<p>​    你是否想过在按下app icon图标时到application::<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application?language=objc">didFinishLaunchingWithOptions</a>:?之间发生了什么</p>
<p>​    iPhone app技术上讲可以概括的描述为一个函数<a href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain">UIApplicationMain(<em>:</em>:<em>:</em>:)</a></p>
<p>​    下面一起探究以下其中原理</p>
<a id="more"></a>

<h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>​    如果你研究UIApplicationMain(<em>:</em>:<em>:</em>:)这个方法,你会发现他的返回值是Int32类型.其实,这个方法从来不会真的退出,直到app退出,和你的app生命周期一致</p>
<p>​    第一件事,app调用一个类<a href="https://developer.apple.com/documentation/uikit/uiapplication">UIApplication</a>这个类非常重要,是控制,协同app运行的关键</p>
<p>​    每个app只有一个该对象实例,是单例模式,UIApplication.shared就是这个单例对象</p>
<h4 id="UIApplicationDelegate"><a href="#UIApplicationDelegate" class="headerlink" title="UIApplicationDelegate"></a>UIApplicationDelegate</h4><p>​    另一件事,创建AppDelegate,是一个遵守<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate">UIApplicationDelegate</a>协议的对象,你可能对它已经很熟悉了,处理app交互的根对象</p>
<p>​    UIApplicationDelegate有一堆方法,用来管理你的app</p>
<p>​    你是否注意到@UIApplicationMain标记在类声明之前?UIApplicationMain(<em>:</em>:<em>:</em>:)根据这个标记知道哪个类是Appdelegate.这个类也是和app的生命周期同步.也被指向为UIApplication的代理对象</p>
<p>​    应用对象遇到重要的runtime事件时,会通知AppDelegate,例如app运行,内存警告,app终止,给予响应的机会</p>
<p>​    在iOS13,上述的一些响应职责被SceneDelegate接手处理了.负责app生命周期的响应职责由appDelegate处理,一些和app显示,窗口交互的响应职责由sceneDelegate处理</p>
<h4 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard?"></a>Storyboard?</h4><p>​    此时,app的基础功能已经就绪了,UIApplicationMain(<em>:</em>:<em>:</em>:)开始准备处理交互了</p>
<p>​    首先,需要找到main storyboard,这个行为是和Info.plist的key叫做”Main storyboard file base name”有关</p>
<p>​    如果使用storyboard绘制界面,app会实例化UIWindow,UIVindow是UIView的子类.这个实例化的window是你用户界面的基础</p>
<p>​    一旦实例化完成,window被赋值SceneDelegate的属性(在iOS13之前是AppDelegate的属性)</p>
<p>​    如果你观察SceneDelegate里的scene(_:willConnectTo:options:)方法,你能注意到瞎买你的注释:</p>
<blockquote>
<p>If using a storyboard, the <code>window</code> property will automatically be initialized and attached to the scene.</p>
</blockquote>
<p>​    现在开始window属性和app生命周期保持一致了</p>
<h4 id="ViewController的初始化"><a href="#ViewController的初始化" class="headerlink" title="ViewController的初始化"></a>ViewController的初始化</h4><p>​    用户虽然创建了UIWindow的实例,但是现在却看不到任何东西的,用户并不会直接和window交互,能看到的是window里的rootViewController属性</p>
<p>​    rootViewController包含着你的initial view controller,你可以通过storyboard指定initial view controller,在”Attributes inspector”,选中”Is initial view controller”</p>
<p>​    选中之后就被赋值给rootViewController属性,它是window现在唯一的直接的subview.其他的view都是rootview的subview</p>
<p>​    现在是时候调用application:didFinishLaunchingWithOptions:方法了</p>
<p>​    但window还是不可见,最一步需要调用<a href="https://developer.apple.com/documentation/uikit/uiwindow/1621601-makekeyandvisible">makeKeyAndVisible()</a>实例方法</p>
<p>​    此时app已经就绪,功能开始执行了</p>
<h4 id="无No-Storyboard"><a href="#无No-Storyboard" class="headerlink" title="无No Storyboard"></a>无No Storyboard</h4><p>​    有些项目不使用storyboard,靠纯代码绘制界面,这种情况下,你必须要在UIApplicationMain里自己写相关代码</p>
<p>​    在iOS13之前,写上述代码的位置在didFinishLaunchingWithOptions,现在要写在SceneDelegate<code>里的 </code>(_willConnectTo:options:)方法里</p>
<p>​    你要写的代码内容:</p>
<ul>
<li>实例化UIWindow,赋值给SceneDelegate<code>’s </code>window属性</li>
<li>实例化你的initial view controller并且赋值给window<code>的 </code>rootViewController属性</li>
<li>调用makeKeyAndVisible()展示界面</li>
</ul>
<p>代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="number">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    window = <span class="keyword">self</span>.window ?? <span class="type">UIWindow</span>()</span><br><span class="line">    window?.backgroundColor = .white</span><br><span class="line">    window?.rootViewController = <span class="type">ViewController</span>()</span><br><span class="line">    window?.makeKeyAndVisible()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = (scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    上述的过程都是不可见的,在app内部处理,很多人没有思考过其中的细节.是app生命周期重要的部分</p>
]]></content>
      <tags>
        <tag>Medium</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>配置高效的开发环境</title>
    <url>/2020/09/26/%E9%85%8D%E7%BD%AE%E9%AB%98%E6%95%88%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>xcode有很多提高效率的功能和配置,介绍一些可以提高效率的配置;包括debug,behavior,快捷键</p>
<a id="more"></a>

<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>cmd+\ 增加,删除断点<br>鼠标拖动断点蓝色标识,删除断点</p>
<h4 id="behavior"><a href="#behavior" class="headerlink" title="behavior"></a>behavior</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">open -a iTerm .</span><br></pre></td></tr></table></figure>
<p>打开终端,并进入到项目目录<br>把脚本放到工程根目录<br>在behavior里配置脚本,选择自定义快捷键,选择run脚本,指定工程根目录下的脚本(注意chmod+x 增加执行权限)<br>每次在xcode可以直接通过快捷键调用出终端,并且在当前项目目录里</p>
]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>提高开发效率的N种方法</title>
    <url>/2020/08/07/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>介绍几种提高mac下开发效率的方法、包括Xcode快捷键、vi快捷键、Alfred工作流、宏</p>
<a id="more"></a> 
<h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><pre><code>ctrl+f                光标向前
ctrl+b                光标向后
ctrl+a                光标行头
ctrl+e                光标行尾
ctrl+shift+f          向前选中
ctrl+shift+b          向后选中
ctrl+shift+a          向前选中至行头
ctrl+shift+e          向后选中至行尾
ctrl+k                向后删除当前行
ctrl+6                搜索当前文件函数
ctril+shift+,         显示scheme配置（build、run等）
cmd+,                 配置工程
ctrl+cmd+up/down      头文件和实现文件切换
ctrl+cmd+left/right   文件历史栈切换</code></pre>
<h3 id="vi快捷键"><a href="#vi快捷键" class="headerlink" title="vi快捷键"></a>vi快捷键</h3><pre><code>shift zz 快速保存退出</code></pre>
<p>​    </p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3>]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM学习</title>
    <url>/2020/10/12/LLVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>LLVM是可重用,可扩展的编译器和工具链后端的集合,可以方便的对新编程语言与新运行平台做最小化的兼容处理</p>
<a id="more"></a>

<h3 id="llvm官网"><a href="#llvm官网" class="headerlink" title="llvm官网"></a>llvm官网</h3><p><a href="https://llvm.org/">https://llvm.org</a></p>
<h3 id="为什么不再使用gcc"><a href="#为什么不再使用gcc" class="headerlink" title="为什么不再使用gcc"></a>为什么不再使用gcc</h3><h6 id="三段式编译工具链"><a href="#三段式编译工具链" class="headerlink" title="三段式编译工具链"></a>三段式编译工具链</h6><ul>
<li><p>gcc是GNU组织的开源的传统三段式的编译器套件</p>
</li>
<li><p>传统的三段式编译工具链如图:</p>
</li>
<li><p>分为前端,优化器,后端</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/krela2010/picstore/master/img/llvm.png"></p>
<ul>
<li><p>前端(Frontend):解析代码,检查静态语法,创建语法树(AST)</p>
</li>
<li><p>优化器(Optimizer):根据选项,做部分代码优化</p>
</li>
<li><p>后端(Backend):生成机器码(汇编)</p>
</li>
</ul>
<p><img src="http://www.aosabook.org/images/llvm/RetargetableCompiler.png" alt="[Retargetablity]"></p>
<p><strong>三段式的优点:</strong></p>
<p>编译器的维护者只需要关注前端的逻辑,和后端分离,避免了为增加一种语言,需要再重复实现后端逻辑的冗余工作量</p>
<p><strong>gcc的问题</strong></p>
<ul>
<li>gcc是一个完整的可执行文件,后端的优化器不能给其它语言提供重用的接口,即使是开源的,对于新增一种语言的代价也很大,需要重新实现相应的前端,优化等逻辑</li>
<li>对于苹果而言,gcc对于自家的语言支持不给力,效率和插件,工具支持薄弱等问题</li>
<li>性能问题gcc效率低,clang更快</li>
<li>对整体工具链的掌控lldb 支持新语言等</li>
</ul>
<h3 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h3><ul>
<li><p>llvm是指的是优化器和后端</p>
</li>
<li><p>llvm全称Low Level Virtual Machine(低级虚拟机),本身定位是虚拟机,类似jvm,属于编译器后端</p>
</li>
<li><p>IR:llvm最重要的一个部分就是IR全程为 Intermediate Representation (中间代码)</p>
</li>
</ul>
<p>优势:</p>
<ul>
<li><p>优化器:共享优化器,每次新增语言都可以重用以前的优化器</p>
</li>
<li><p>llvm下的三段式编译结构</p>
</li>
</ul>
<p><img src="http://www.aosabook.org/images/llvm/LLVMCompiler1.png" alt="[LLVM&#39;s Implementation of the Three-Phase Design]"></p>
<ul>
<li><p>Clang是c语言系列的前端编译器,</p>
</li>
<li><p>swift是swift语言的前端编译器,相比Clang多了sil</p>
<ul>
<li>Swift 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化</li>
</ul>
</li>
</ul>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><ol>
<li><p>预处理:</p>
<ol>
<li>宏展开</li>
</ol>
</li>
<li><p>词法分析</p>
<ol>
<li><p>词法分析</p>
</li>
<li><p>预处理代码文本转为token</p>
</li>
<li><p>不校验语义</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$clang</span> -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span></span><br></pre></td></tr></table></figure>

<p>展示为以token为单位的结构代码</p>
</li>
</ol>
</li>
<li><p>语法分析(Semantic Analysis)</p>
<ol>
<li><p>Clang中由Parser和Sema两个模块实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#clang</span> <span class="selector-tag">-fmodules</span> <span class="selector-tag">-fsyntax-only</span> <span class="selector-tag">-Xclang</span> <span class="selector-tag">-ast-dump</span> <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br></pre></td></tr></table></figure>

<p>生成语法树</p>
<p><strong>静态分析(Static Analysis)</strong></p>
<ol>
<li>通过语法树进行静态分析,找出非语法性错误</li>
<li>`模拟代码执行路径,</li>
<li>Checker</li>
</ol>
</li>
</ol>
</li>
<li><p>CodeGen-IR 代码生成</p>
<ol>
<li>与oc runtime桥接<ol>
<li>Class/Meta Class/Protocol/Category内存结构生成,放在指定section中</li>
<li>Method/Ivar/Property内存结构生成</li>
<li>Class中method_list/ivar_list/property_list结构生成</li>
</ol>
</li>
<li>BitCode<ol>
<li>IR 生成二进制码</li>
</ol>
</li>
</ol>
</li>
<li><p>生成汇编(Assemble)</p>
</li>
<li><p>生成Target相关Object(Mach-O)</p>
</li>
<li><p>链接</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/krela2010/picstore/img/llvm-03.png"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p>
</li>
<li><p>《玩转编译器，Clang有意思》 –sunny孙源</p>
</li>
</ul>
]]></content>
  </entry>
</search>
