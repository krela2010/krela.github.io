<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>提高开发效率的N种方法</title>
    <url>/2020/08/07/iOS/</url>
    <content><![CDATA[<p>介绍几种提高mac下开发效率的方法、包括Xcode快捷键、vi快捷键、Alfred工作流、宏</p>
<a id="more"></a> 
<h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><pre><code>ctrl+f                光标向前
ctrl+b                光标向后
ctrl+a                光标行头
ctrl+e                光标行尾
ctrl+shift+f          向前选中
ctrl+shift+b          向后选中
ctrl+shift+a          向前选中至行头
ctrl+shift+e          向后选中至行尾
ctrl+k                向后删除当前行
ctrl+6                搜索当前文件函数
ctril+shift+,         显示scheme配置（build、run等）
cmd+,                 配置工程
ctrl+cmd+up/down      头文件和实现文件切换
ctrl+cmd+left/right   文件历史栈切换</code></pre>
<h3 id="vi快捷键"><a href="#vi快捷键" class="headerlink" title="vi快捷键"></a>vi快捷键</h3><pre><code>shift zz 快速保存退出</code></pre>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>#<div class="video-container"><iframe src="https://www.youtube.com/embed/DBWu6TnhLeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>
]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>效率</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(上)</title>
    <url>/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前五章内容：<br>熟悉oc 1-5<br>对象、消息、runtime 6-14<br>接口与API 15-22<br>协议与分类 23-28<br>内存管理 29-36</p>
<a id="more"></a>
<h3 id="1-oc起源"><a href="#1-oc起源" class="headerlink" title="1.oc起源"></a>1.oc起源</h3><h3 id="2-减少头文件引用"><a href="#2-减少头文件引用" class="headerlink" title="2.减少头文件引用"></a>2.减少头文件引用</h3><ul>
<li>如果不使用类方法可以仅声明@class Class 即可</li>
</ul>
<h3 id="3-多用字面量"><a href="#3-多用字面量" class="headerlink" title="3.多用字面量"></a>3.多用字面量</h3><ul>
<li>代码整洁、直观</li>
<li>NSArray arrayWithObject：遇到nil不会崩溃，内部会判断</li>
</ul>
<h3 id="4-少用define"><a href="#4-少用define" class="headerlink" title="4.少用define"></a>4.少用define</h3><ul>
<li>建议使用const来替代：<ol>
<li>可以加static 控制作用域、避免冲突</li>
<li>类型含义明确，维护性好</li>
<li>static 编译器会自行优化为define</li>
</ol>
</li>
</ul>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><ul>
<li>占用1字节</li>
<li>type NS_ENUM oc枚举<ol>
<li>根据编译平台决定使用新、旧协议(c++)</li>
<li>新协议指的是底层数据类型存储</li>
<li>switch 处理enum分支；尽量不用default，覆盖每一个分支，避免新增enum，switch未处理的情况</li>
</ol>
</li>
</ul>
<h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><ul>
<li>类对象保管存储偏移量</li>
<li>@dynamic 配合CoreData动态添加方法</li>
</ul>
<h3 id="7-对象内部使用实例变量"><a href="#7-对象内部使用实例变量" class="headerlink" title="7.对象内部使用实例变量"></a>7.对象内部使用实例变量</h3><ul>
<li><p>self.var 语法</p>
<ol>
<li>效率低</li>
<li>可触发kvo，可使用懒加载</li>
</ol>
</li>
<li><p><code>_var</code> 语法</p>
<ol>
<li>不触发kvo</li>
<li>getter语法里使用</li>
</ol>
</li>
<li><p>折中方案</p>
<ol>
<li>写入用setter</li>
<li>读取用_var</li>
</ol>
</li>
</ul>
<h3 id="8-对象等同性"><a href="#8-对象等同性" class="headerlink" title="8.对象等同性"></a>8.对象等同性</h3><ul>
<li>isEqualToString比isEqual快</li>
<li>== 判断指针操作</li>
<li>hash()方法用于比较，自己实现；注意set时 的hash 碰撞问题</li>
<li>结构对象使用主键比较</li>
</ul>
<h3 id="9-类簇"><a href="#9-类簇" class="headerlink" title="9.类簇"></a>9.类簇</h3><ul>
<li>oc没有概念上的抽象类，oc的抽象类不写init</li>
<li>类簇类似抽象类的概念，提供接口，不提供实现</li>
<li>NSArray 里面是工厂，NSArray class 隐藏 无法通过实例访问<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[arr <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[str <span class="keyword">class</span>], [<span class="built_in">NSString</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">///分别打印</span></span><br><span class="line">__NSArray0|<span class="built_in">NSArray</span></span><br><span class="line">__NSCFConstantString|<span class="built_in">NSString</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-动态添加属性"><a href="#10-动态添加属性" class="headerlink" title="10.动态添加属性"></a>10.动态添加属性</h3><ul>
<li>本质是全局创建Map，以Class为key的外部表</li>
<li>示例：UIAlertView存在多个，通过此方法区分每个；不建议这么用；不好定位异常</li>
</ul>
<h3 id="11-消息派发"><a href="#11-消息派发" class="headerlink" title="11.消息派发"></a>11.消息派发</h3><ul>
<li>objc_msg_send 有两个隐藏参数 (id,SEL)</li>
<li>runtime</li>
<li>尾调用优化：去掉函数栈帧，优化</li>
</ul>
<h3 id="12-消息转发"><a href="#12-消息转发" class="headerlink" title="12.消息转发"></a>12.消息转发</h3><ul>
<li>resolveInstanceMethod/resolveClassMethod<ol>
<li>配合@dynamic</li>
</ol>
</li>
<li>备用接受者 forwardingTargetForSelector<ol>
<li>返回接收对象</li>
<li>1对1</li>
<li>快速</li>
</ol>
</li>
<li>完成消息转发forwardInvocation<ol>
<li>修改方法内容</li>
<li>1对多</li>
<li>慢</li>
</ol>
</li>
</ul>
<h3 id="13-方法交换"><a href="#13-方法交换" class="headerlink" title="13.方法交换"></a>13.方法交换</h3><ul>
<li>用于调试目的<ol>
<li>用户行为监控</li>
<li>调试异常</li>
<li>一般应用层不建议使用</li>
</ol>
</li>
</ul>
<h3 id="14-类对象意义"><a href="#14-类对象意义" class="headerlink" title="14.类对象意义"></a>14.类对象意义</h3><ul>
<li>判断对象关系 isKindOf isMemberOf；</li>
<li>示例：NSProxy 对于isKinfOf 对 class处理可能不一样(消息转发)</li>
<li>消息传递机制的前提</li>
</ul>
<h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul>
<li>c函数需要加前缀</li>
<li>lib对象，自己引用的第三方加前缀</li>
</ul>
<h3 id="16-全能初始化器"><a href="#16-全能初始化器" class="headerlink" title="16.全能初始化器"></a>16.全能初始化器</h3><ul>
<li><p>和swift的指定初始化器类似，swift 强制性 oc 没有这种约束 designted翻译差异。</p>
</li>
<li><p>中文翻译的怪怪的；<br> 我的翻译是：<br> <strong>目标是为了实例的初始化能保证类和其父类的所有成员得到初始化</strong></p>
<ol>
<li>全能初始化器的作用是为了保证当前类成员得到初始化</li>
<li>非全能初始化器应调用当前类全能初始化器</li>
<li>子类的全能初始化器必须调用父类的全能初始化器</li>
<li>如果父类的全能初始化器，子类没有实现，那么实例可以直接调用父类的全能初始化器初始化，子类成员变量没有初始化。为了解决这个问题，要么 抛异常，要么 重写父类的全能初始化器</li>
</ol>
<p> <strong>这块swift做成了编译检查，而且swift官方文档描述的更清楚</strong></p>
</li>
</ul>
<h3 id="17-实现descripion方法"><a href="#17-实现descripion方法" class="headerlink" title="17.实现descripion方法"></a>17.实现descripion方法</h3><ul>
<li>自己实现的建议加上类名称和对象地址</li>
<li>lldb里po 打印的是debugDescripion</li>
</ul>
<h3 id="18-使用不可变对象"><a href="#18-使用不可变对象" class="headerlink" title="18.使用不可变对象"></a>18.使用不可变对象</h3><ul>
<li>涉及到扩展的作用外部ro，内部rw可以点语法修改</li>
<li>成员变量对外不可变，修改交给类内部</li>
</ul>
<h3 id="19-命名方式"><a href="#19-命名方式" class="headerlink" title="19.命名方式"></a>19.命名方式</h3><h3 id="20-为私有方法加前缀"><a href="#20-为私有方法加前缀" class="headerlink" title="20.为私有方法加前缀"></a>20.为私有方法加前缀</h3><ul>
<li>oc由于动态机制，没有所谓的private函数</li>
<li>不要用_作为前缀，和苹果自带的冲突</li>
</ul>
<h3 id="21-oc错误类型"><a href="#21-oc错误类型" class="headerlink" title="21.oc错误类型"></a>21.oc错误类型</h3><ul>
<li>使用抽象类建议抛出异常</li>
<li>NSError** 使用</li>
</ul>
<h3 id="22-NSCopying协议"><a href="#22-NSCopying协议" class="headerlink" title="22.NSCopying协议"></a>22.NSCopying协议</h3><ul>
<li>copy方法调用copyWithZone；注意重写的应是copyWithZone</li>
</ul>
<h3 id="23-delegate对象间通信"><a href="#23-delegate对象间通信" class="headerlink" title="23.delegate对象间通信"></a>23.delegate对象间通信</h3><ul>
<li>delegate属性weak</li>
<li>自定义代理调用需要判断是否实现方法</li>
<li>位域代替responseToselector</li>
</ul>
<h3 id="24-类拆分成多个分类"><a href="#24-类拆分成多个分类" class="headerlink" title="24.类拆分成多个分类"></a>24.类拆分成多个分类</h3><ul>
<li>方便管理类</li>
<li>函数调用栈里可以看到分类信息</li>
</ul>
<h3 id="25-分类方法加前缀"><a href="#25-分类方法加前缀" class="headerlink" title="25.分类方法加前缀"></a>25.分类方法加前缀</h3><ul>
<li>分类加前缀</li>
<li>分类方法加前缀</li>
</ul>
<h3 id="26-分类中不能添加属性"><a href="#26-分类中不能添加属性" class="headerlink" title="26.分类中不能添加属性"></a>26.分类中不能添加属性</h3><ul>
<li>可以通过同名函数做到模拟属性的效果 不推荐</li>
<li>关联值添加属性 不推荐<br>感觉翻译的还是有点问题<br>原文：<em>“你可能通过属性特质修改了某个属性的管理语义”</em><br>理解：如果要给一个类批量修改属性@property，一般只记得在主类的头文件修改；如果设置了关联值，很可能忘记修改，维护性差</li>
</ul>
<h3 id="27-匿名分类隐藏实现细节"><a href="#27-匿名分类隐藏实现细节" class="headerlink" title="27.匿名分类隐藏实现细节"></a>27.匿名分类隐藏实现细节</h3><ul>
<li>和c++混编时，c++对象放到匿名分类里，避免重复引用头文件造成</li>
<li>修改ro属性，内部为rw</li>
<li>隐藏遵守的协议</li>
<li>私有属性，没在.h里，一般看不到；私有变量和放在impl里作用相同</li>
</ul>
<h3 id="28-协议实现匿名函数"><a href="#28-协议实现匿名函数" class="headerlink" title="28.协议实现匿名函数"></a>28.协议实现匿名函数</h3><ul>
<li>pop面向协议编程</li>
<li>隐藏实现，仅暴露协议内容</li>
</ul>
<h3 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h3><ul>
<li>retainCount 不推荐；因为如果autorelease了retainCount值不准确</li>
<li>mrc return [对象 autorelease],避免调用者不释放</li>
</ul>
<h3 id="30-ARC简化引用计数"><a href="#30-ARC简化引用计数" class="headerlink" title="30.ARC简化引用计数"></a>30.ARC简化引用计数</h3><ul>
<li>autorelease 后的返回函数 接收强类型对象 编译会自动retain</li>
<li>不能复写release函数</li>
<li>CF对象自行释放</li>
</ul>
<h3 id="31-dealloc作用"><a href="#31-dealloc作用" class="headerlink" title="31.dealloc作用"></a>31.dealloc作用</h3><ul>
<li>不要调用存取方法</li>
<li>可能并不会触发、在应用异常退出；可以在ApplicationWillTerminate里释放</li>
<li>某些文件句柄、socket系统映射文件，不要直接释放、调用相应close方法</li>
<li>释放c对象</li>
<li>释放通知、kvo</li>
<li></li>
</ul>
<h3 id="32-捕获异常"><a href="#32-捕获异常" class="headerlink" title="32.捕获异常"></a>32.捕获异常</h3><ul>
<li>arc 下不建议 try catch ，加很多辅助代码</li>
<li>如果objc++ 可以处理try catch</li>
</ul>
<h3 id="33-弱引用避免循环引用"><a href="#33-弱引用避免循环引用" class="headerlink" title="33.弱引用避免循环引用"></a>33.弱引用避免循环引用</h3><ul>
<li>weak属性 避免出现引用闭环</li>
</ul>
<h3 id="34-自动释放块"><a href="#34-自动释放块" class="headerlink" title="34.自动释放块"></a>34.自动释放块</h3><ul>
<li>可以在循环中创建对象使用，控制内存</li>
</ul>
<h3 id="35-僵尸对象调试"><a href="#35-僵尸对象调试" class="headerlink" title="35.僵尸对象调试"></a>35.僵尸对象调试</h3><ul>
<li>打开编译开关</li>
<li>原理：生成僵尸子类，由僵尸子类处理消息</li>
</ul>
<h3 id="36-retainCount"><a href="#36-retainCount" class="headerlink" title="36.retainCount"></a>36.retainCount</h3><ul>
<li>不建议用</li>
<li>由于autorelease，某一个时刻不代表真实值</li>
<li>优化原因，可能永远不为0</li>
<li>常量区对象也会有retainCount值，int.max</li>
</ul>
]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Tranquilpeak主题配置</title>
    <url>/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hexo Tranquilpeak 主题配置</p>
<a id="more"></a>

<p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/09/08/Markdown/</url>
    <content><![CDATA[<p>常用Markdown编辑工具和语法</p>
<a id="more"></a>
<h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>网站：<a href="http://typora.io/">http://typora.io</a><br>支持Mac windows</p>
<h3 id="2-Dillinger"><a href="#2-Dillinger" class="headerlink" title="2.Dillinger"></a>2.Dillinger</h3><p>网站：<a href="http://dillinger.io/">http://dillinger.io</a><br>在线编辑</p>
<h3 id="3-印象笔记"><a href="#3-印象笔记" class="headerlink" title="3.印象笔记"></a>3.印象笔记</h3><p>支持多平台</p>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><blockquote>
<p><code># 大标题(注意有空格)</code><br><code>### 次标题 </code><br><code>##### 依次递减</code><br><code>*斜体*</code><br><code>**重点**</code><br><code>- list 列表(支持层级)</code><br><code>&gt; hello 引用样式(支持层级)</code><br><code>-[] checkBox 代办</code><br><code>*** 分隔线</code><br><code>--- 分隔线</code><br><code>|   |   |</code><br><code>|-|-|</code><br><code>|   |   |</code><br>表格(各个工具可能有差异，typora支持的好)<code> </code> <code>  代码块` 两行之间 `</code>c++ 根据语法着色`</p>
</blockquote>
<p>更多语法：<br><a href="https://www.jianshu.com/p/b03a8d7b1719">https://www.jianshu.com/p/b03a8d7b1719</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>架构学习的记录</p>
<a id="more"></a>
<h3 id="组件化设计"><a href="#组件化设计" class="headerlink" title="组件化设计"></a>组件化设计</h3><p>1.功能模块，互相解耦，通过中间层调用<br>2.公共组件抽离，统一维护管理<br>3.开发人员只做业务</p>
<p>优点：插件化，业务调整，之间互不影响<br>缺点：公共组件的统一维护可以提高效率，但也存在风险</p>
<h3 id="极端分离设计"><a href="#极端分离设计" class="headerlink" title="极端分离设计"></a>极端分离设计</h3><p>非专业叫法<br>1.所有模块、及其涉及的通用模块完全独立管理，完全解耦<br>2.模块之间 字典数据传递</p>
<p>优点：完全的模块分离<br>缺点：开发成本高，适合大型、多开发团队的App</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>挖坑，持续填坑</p>
<a id="more"></a>

<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>C负责M和V的对象管理和生命周期</li>
<li>M和V完全分离</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>C的业务负担较重</li>
</ul>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul>
<li>MVP+C ，本质还有C的存在</li>
<li>C持有P对象，P弱引用C</li>
<li>P的定位和MVC中的C类似，相当于把C的工作拆分成多个P，每个P负责部分业务功能，</li>
<li>C负责管理P对象管理和生命周期，对P做业务扩展</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul>
<li>MVVM+C   类似MVP，C可以有多个VM</li>
<li>VM持有M对象，持有V的对象</li>
<li>V不引用VM的头文件，只声明类型；和M分离</li>
<li>数据响应不再是VM发起，有V建立观察器去监听变化；<br>  实现方法：kvo，KVOController，RAC</li>
</ul>
<h5 id="优点：-进一步减少了VM的负担"><a href="#优点：-进一步减少了VM的负担" class="headerlink" title="优点： 进一步减少了VM的负担"></a>优点： 进一步减少了VM的负担</h5><p>理解还是片面,待整理<br><a href="https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f">https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f</a><br><a href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm">https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm</a></p>
<h3 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h3>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-oc 笔记(下)</title>
    <url>/2020/09/09/Effective-oc-%E7%AC%94%E8%AE%B0%EF%BC%88%EF%BC%89/</url>
    <content><![CDATA[<p>6、7章<br>Block和GCD 37-46<br>系统框架 47-52</p>
<a id="more"></a>
<h3 id="37-理解Block"><a href="#37-理解Block" class="headerlink" title="37.理解Block"></a>37.理解Block</h3><ul>
<li>block在定义范围有效；栈block的生命周期，括号范围内</li>
<li>堆block，生命周期被管理</li>
</ul>
<h3 id="38-typedef-常用Block"><a href="#38-typedef-常用Block" class="headerlink" title="38.typedef 常用Block"></a>38.typedef 常用Block</h3><ul>
<li>typdef void(^DKBLock)(void *);</li>
<li>好处 修改方便、易读</li>
<li>建议根据使用场景，同类型block 声明为不同name</li>
</ul>
<h3 id="39-Block的好处"><a href="#39-Block的好处" class="headerlink" title="39.Block的好处"></a>39.Block的好处</h3><ul>
<li>delegate的缺点、如果包含多个委托，同一个函数要区分</li>
<li>block更集中，易维护、易读</li>
<li>建议多个参数，整理为一个handler，参数之间可以配合使用</li>
</ul>
<h3 id="40-块里的循环引用问题"><a href="#40-块里的循环引用问题" class="headerlink" title="40.块里的循环引用问题"></a>40.块里的循环引用问题</h3><ul>
<li>主动打破 块里将block对象释放（不执行就会有问题）</li>
<li>block持有者 使用完处理掉</li>
</ul>
<h3 id="41-多用派发队列，少用锁"><a href="#41-多用派发队列，少用锁" class="headerlink" title="41.多用派发队列，少用锁"></a>41.多用派发队列，少用锁</h3><ul>
<li>多个synchronized(self),共享锁，不推荐</li>
<li>异步调用设置方法，由于涉及拷贝块，衡量下拷贝和执行的速度</li>
</ul>
<h3 id="42-多用GCD，少用performSelector"><a href="#42-多用GCD，少用performSelector" class="headerlink" title="42.多用GCD，少用performSelector"></a>42.多用GCD，少用performSelector</h3><ul>
<li>performSelector局限多，参数支持最多2个</li>
<li>performSelector返回值限定id，基础类型需要做转换；返回值是c语言结构体就不建议用</li>
</ul>
<h3 id="43-GCD和NSOperation"><a href="#43-GCD和NSOperation" class="headerlink" title="43.GCD和NSOperation"></a>43.GCD和NSOperation</h3><ul>
<li>dispatch_once 执行一次；单例</li>
<li>NSOperation：可以取消、依赖、kvo观察任务状态</li>
</ul>
<h3 id="44-Dispatch-Group"><a href="#44-Dispatch-Group" class="headerlink" title="44.Dispatch Group"></a>44.Dispatch Group</h3><ul>
<li>dispatch_group_wait 阻塞等待完成执行</li>
<li>dispatch_group_notify 非阻塞等待完成</li>
<li>dispatch_apply </li>
</ul>
<h3 id="45-dispatch-once"><a href="#45-dispatch-once" class="headerlink" title="45.dispatch_once"></a>45.dispatch_once</h3><p>标准推荐写法</p>
<blockquote>
<p>static Class *instance = nil;<br>static dispatch_group_t token;<br>dispatch_once {&amp;token, ^{ instance = [[Class alloc]init]}}<br>return instance;</p>
</blockquote>
<ul>
<li>比synchronized快</li>
</ul>
<h3 id="46-不要使用dispatch-get-current-queue"><a href="#46-不要使用dispatch-get-current-queue" class="headerlink" title="46.不要使用dispatch_get_current_queue"></a>46.不要使用dispatch_get_current_queue</h3><h1 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h1><h3 id="47"><a href="#47" class="headerlink" title="47."></a>47.</h3>]]></content>
      <tags>
        <tag>oc</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/20200910213941/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>frame 和 bounds</title>
    <url>/2020/09/11/frame-%E5%92%8C-bounds/</url>
    <content><![CDATA[<h5 id="概念上frame以parentView为基准-bonuds以自己为基准"><a href="#概念上frame以parentView为基准-bonuds以自己为基准" class="headerlink" title="概念上frame以parentView为基准,bonuds以自己为基准"></a>概念上frame以parentView为基准,bonuds以自己为基准</h5><a id="more"></a>
<h3 id="在正常的情况下-非transform"><a href="#在正常的情况下-非transform" class="headerlink" title="在正常的情况下(非transform)"></a>在正常的情况下(非transform)</h3><p><strong>调整size</strong><br>1.frame和bonuds的size一样<br>2.调整view的frame的size,bonuds也会跟着改<br>3.调整bonuds的size,bonuds会以view的中心点固定调整,frame的size同步,但origin的坐标会根据发生变化.<br>例如bonuds的width由200变为160,变化值40,frame的origin.x 会 +20</p>
<p><strong>调整origin</strong><br>1.调整frame的origin,位置发生变化,bonuds的origin不变<br>2.调整bounds的origin(很少调整),位置发生绝对值变化,frame得origin跟着同步;特殊的是,如果有subView,<br>subView的绝对位置没变,不跟着父view调整</p>
<h3 id="transform下"><a href="#transform下" class="headerlink" title="transform下"></a>transform下</h3><p>1.bounds不变<br>2.frame是包含view的最小正方形</p>
<p>文字描述,不好理解<br>详细 参考<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603">https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603</a></p>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
  <entry>
    <title>20200915133333</title>
    <url>/2020/09/15/20200915133333/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>快速实现CollectionView的无限轮播器</title>
    <url>/2020/09/15/%E5%AE%9E%E7%8E%B0CollectionView%E7%9A%84%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/600/1*ZYZmgctLW304fZ3UqYheLw.gif" alt="avatar"><br>通过CollectionView快速实现一个无限轮播器,基于原生uikit</p>
<a id="more"></a>

<p>核心逻辑是在collection的dateSource</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> infiniteSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>infiniteSize可以指定一个非常大的值,但不要指定Int.max,会越界崩溃</p>
<p>例如<br><em>let infiniteSize = 100000</em></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func collection<span class="constructor">View(<span class="params">_</span> <span class="params">collectionView</span>: UICollectionView, <span class="params">cellForItemAt</span> <span class="params">indexPath</span>: IndexPath)</span> -&gt; UICollectionViewCell &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = collectionView.dequeue<span class="constructor">ReusableCell(<span class="params">withReuseIdentifier</span>: <span class="string">&quot;ColorCell&quot;</span>, <span class="params">for</span>: <span class="params">indexPath</span>)</span></span><br><span class="line">  cell.backgroundColor = colorList<span class="literal">[<span class="identifier">indexPath</span>.<span class="identifier">row</span> % <span class="identifier">colorList</span>.<span class="identifier">count</span>]</span></span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cell通过对集合取余来控制集合索引<br>写完之后,现在可以实现向右的无限滑动,目前,但是向左还不行</p>
<h4 id="原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果"><a href="#原理就是通过设置一个很大的数量itemSize-来模拟无限循环的效果" class="headerlink" title="原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果"></a>原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果</h4><p>向左的思路是把默认的collection的索引指向itemSize的中间值,这样左右都有infiniteSize/2的数量了</p>
<p>可以在viewDidload中加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let midIndexPath &#x3D; IndexPath(row: infiniteSize &#x2F; size &#x2F; 2 * size, section: 0)</span><br><span class="line">             collectionView.scrollToItem(at: midIndexPath,</span><br><span class="line">                                              at: .centeredHorizontally,</span><br><span class="line">                                        animated: false)</span><br></pre></td></tr></table></figure>

<p>size是数据容器的大小,确保index指向容器的第一个</p>
<p>这样就完成了,方法比较取巧,</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>快速,方便</li>
<li>由于reuseable的cell并不会占用内存资源</li>
<li>原生实现,易于维护</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>伪无限循环,到了infinitySize上限,就滚不动了</li>
</ul>
]]></content>
      <tags>
        <tag>uikit</tag>
      </tags>
  </entry>
</search>
