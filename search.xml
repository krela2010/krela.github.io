<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速实现CollectionView的无限轮播器</title>
      <link href="/2020/09/15/%E5%AE%9E%E7%8E%B0CollectionView%E7%9A%84%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%99%A8/"/>
      <url>/2020/09/15/%E5%AE%9E%E7%8E%B0CollectionView%E7%9A%84%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://miro.medium.com/max/600/1*ZYZmgctLW304fZ3UqYheLw.gif" alt="avatar"><br>通过CollectionView快速实现一个无限轮播器,基于原生uikit</p><a id="more"></a><p>核心逻辑是在collection的dateSource</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> infiniteSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>infiniteSize可以指定一个非常大的值,但不要指定Int.max,会越界崩溃</p><p>例如<br><em>let infiniteSize = 100000</em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">&quot;ColorCell&quot;</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">  cell.backgroundColor = colorList[indexPath.row % colorList.<span class="built_in">count</span>]</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">cell通过对集合取余来控制集合索引</span><br><span class="line">写完之后,现在可以实现向右的无限滑动</span><br><span class="line">#### 原理就是通过设置一个很大的数量itemSize,来模拟无限循环的效果</span><br><span class="line"></span><br><span class="line">目前,但是向左还不行</span><br><span class="line"></span><br><span class="line">向左的思路是把默认的collection的索引指向itemSize的中间值,这样左右都有infiniteSize/<span class="number">2</span>的数量了</span><br><span class="line"></span><br><span class="line">可以在viewDidload中加上</span><br><span class="line">```(swift)</span><br><span class="line"><span class="keyword">let</span> midIndexPath = <span class="type">IndexPath</span>(row: infiniteSize / size / <span class="number">2</span> * size, section: <span class="number">0</span>)</span><br><span class="line">             collectionView.scrollToItem(at: midIndexPath,</span><br><span class="line">                                              at: .centeredHorizontally,</span><br><span class="line">                                        animated: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>size是数据容器的大小,确保index指向容器的第一个</p><p>这样就完成了,方法比较取巧,</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>快速,方便</li><li>由于reuseable的cell并不会占用内存资源</li><li>原生实现,易于维护</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>伪无限循环,到了infinitySize上限,就滚不动了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> uikit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20200915133333</title>
      <link href="/2020/09/15/20200915133333/"/>
      <url>/2020/09/15/20200915133333/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>frame 和 bounds</title>
      <link href="/2020/09/11/frame-%E5%92%8C-bounds/"/>
      <url>/2020/09/11/frame-%E5%92%8C-bounds/</url>
      
        <content type="html"><![CDATA[<h5 id="概念上frame以parentView为基准-bonuds以自己为基准"><a href="#概念上frame以parentView为基准-bonuds以自己为基准" class="headerlink" title="概念上frame以parentView为基准,bonuds以自己为基准"></a>概念上frame以parentView为基准,bonuds以自己为基准</h5><h3 id="在正常的情况下-非transform"><a href="#在正常的情况下-非transform" class="headerlink" title="在正常的情况下(非transform)"></a>在正常的情况下(非transform)</h3><p><strong>调整size</strong><br>1.frame和bonuds的size一样<br>2.调整view的frame的size,bonuds也会跟着改<br>3.调整bonuds的size,bonuds会以view的中心点固定调整,frame的size同步,但origin的坐标会根据发生变化.<br>例如bonuds的width由200变为160,变化值40,frame的origin.x 会 +20</p><p><strong>调整origin</strong><br>1.调整frame的origin,位置发生变化,bonuds的origin不变<br>2.调整bounds的origin(很少调整),位置发生绝对值变化,frame得origin跟着同步;特殊的是,如果有subView,<br>subView的绝对位置没变,不跟着父view调整</p><h3 id="transform下"><a href="#transform下" class="headerlink" title="transform下"></a>transform下</h3><p>1.bounds不变<br>2.frame是包含view的最小正方形</p><p>文字描述,不好理解<br>详细 参考<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603">https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/ios-sdk-%E7%9A%84-frame-bounds-c54a4bfd9603</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> uikit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20200910213941</title>
      <link href="/2020/09/10/20200910213941/"/>
      <url>/2020/09/10/20200910213941/</url>
      
        <content type="html"><![CDATA[<p>常见问题</p><h3 id="删除sceneDelegate"><a href="#删除sceneDelegate" class="headerlink" title="删除sceneDelegate"></a>删除sceneDelegate</h3><p>info.plist<br>Application Scene Maifest 删除<br>AppDelegate里加上：var window: UIWindow?<br>删除scene相关的代码</p><h3 id="NavgationController"><a href="#NavgationController" class="headerlink" title="NavgationController"></a>NavgationController</h3><p>不能再被NavgationController指向，会有2个bar</p><h3 id="Float-amp-CGFloat"><a href="#Float-amp-CGFloat" class="headerlink" title="Float &amp; CGFloat"></a>Float &amp; CGFloat</h3><p>The Float and CGFloat data types sound so similar you might think they were identical, but they aren’t: CGFloat is flexible in that its precision adapts to the type of device it’s running on, whereas Float is always a fixed precision. Thus, you never lose precision converting from Float to CGFloat, whereas you might going the other way</p><p>let myCGFloat = CGFloat(myFloat)</p><h3 id="bonuds-amp-frame"><a href="#bonuds-amp-frame" class="headerlink" title="bonuds &amp; frame"></a>bonuds &amp; frame</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective-oc 笔记(下)</title>
      <link href="/2020/09/09/Effective-oc-%E7%AC%94%E8%AE%B0%EF%BC%88%EF%BC%89/"/>
      <url>/2020/09/09/Effective-oc-%E7%AC%94%E8%AE%B0%EF%BC%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>6、7章<br>Block和GCD 37-46<br>系统框架 47-52</p><a id="more"></a><h3 id="37-理解Block"><a href="#37-理解Block" class="headerlink" title="37.理解Block"></a>37.理解Block</h3><ul><li>block在定义范围有效；栈block的生命周期，括号范围内</li><li>堆block，生命周期被管理</li></ul><h3 id="38-typedef-常用Block"><a href="#38-typedef-常用Block" class="headerlink" title="38.typedef 常用Block"></a>38.typedef 常用Block</h3><ul><li>typdef void(^DKBLock)(void *);</li><li>好处 修改方便、易读</li><li>建议根据使用场景，同类型block 声明为不同name</li></ul><h3 id="39-Block的好处"><a href="#39-Block的好处" class="headerlink" title="39.Block的好处"></a>39.Block的好处</h3><ul><li>delegate的缺点、如果包含多个委托，同一个函数要区分</li><li>block更集中，易维护、易读</li><li>建议多个参数，整理为一个handler，参数之间可以配合使用</li></ul><h3 id="40-块里的循环引用问题"><a href="#40-块里的循环引用问题" class="headerlink" title="40.块里的循环引用问题"></a>40.块里的循环引用问题</h3><ul><li>主动打破 块里将block对象释放（不执行就会有问题）</li><li>block持有者 使用完处理掉</li></ul><h3 id="41-多用派发队列，少用锁"><a href="#41-多用派发队列，少用锁" class="headerlink" title="41.多用派发队列，少用锁"></a>41.多用派发队列，少用锁</h3><ul><li>多个synchronized(self),共享锁，不推荐</li><li>异步调用设置方法，由于涉及拷贝块，衡量下拷贝和执行的速度</li></ul><h3 id="42-多用GCD，少用performSelector"><a href="#42-多用GCD，少用performSelector" class="headerlink" title="42.多用GCD，少用performSelector"></a>42.多用GCD，少用performSelector</h3><ul><li>performSelector局限多，参数支持最多2个</li><li>performSelector返回值限定id，基础类型需要做转换；返回值是c语言结构体就不建议用</li></ul><h3 id="43-GCD和NSOperation"><a href="#43-GCD和NSOperation" class="headerlink" title="43.GCD和NSOperation"></a>43.GCD和NSOperation</h3><ul><li>dispatch_once 执行一次；单例</li><li>NSOperation：可以取消、依赖、kvo观察任务状态</li></ul><h3 id="44-Dispatch-Group"><a href="#44-Dispatch-Group" class="headerlink" title="44.Dispatch Group"></a>44.Dispatch Group</h3><ul><li>dispatch_group_wait 阻塞等待完成执行</li><li>dispatch_group_notify 非阻塞等待完成</li><li>dispatch_apply </li></ul><h3 id="45-dispatch-once"><a href="#45-dispatch-once" class="headerlink" title="45.dispatch_once"></a>45.dispatch_once</h3><p>标准推荐写法</p><blockquote><p>static Class *instance = nil;<br>static dispatch_group_t token;<br>dispatch_once {&amp;token, ^{ instance = [[Class alloc]init]}}<br>return instance;</p></blockquote><ul><li>比synchronized快</li></ul><h3 id="46-不要使用dispatch-get-current-queue"><a href="#46-不要使用dispatch-get-current-queue" class="headerlink" title="46.不要使用dispatch_get_current_queue"></a>46.不要使用dispatch_get_current_queue</h3><h1 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h1><h3 id="47"><a href="#47" class="headerlink" title="47."></a>47.</h3>]]></content>
      
      
      
        <tags>
            
            <tag> oc </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>挖坑，持续填坑</p><a id="more"></a><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li>C负责M和V的对象管理和生命周期</li><li>M和V完全分离</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>C的业务负担较重</li></ul><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul><li>MVP+C ，本质还有C的存在</li><li>C持有P对象，P弱引用C</li><li>P的定位和MVC中的C类似，相当于把C的工作拆分成多个P，每个P负责部分业务功能，</li><li>C负责管理P对象管理和生命周期，对P做业务扩展</li></ul><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul><li>MVVM+C   类似MVP，C可以有多个VM</li><li>VM持有M对象，持有V的对象</li><li>V不引用VM的头文件，只声明类型；和M分离</li><li>数据响应不再是VM发起，有V建立观察器去监听变化；<br>  实现方法：kvo，KVOController，RAC</li></ul><h5 id="优点：-进一步减少了VM的负担"><a href="#优点：-进一步减少了VM的负担" class="headerlink" title="优点： 进一步减少了VM的负担"></a>优点： 进一步减少了VM的负担</h5><p>理解还是片面,待整理<br><a href="https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f">https://medium.com/@dev.omartarek/mvp-vs-mvvm-in-ios-using-swift-337884d4fc6f</a><br><a href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm">https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm</a></p><h3 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计</title>
      <link href="/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/09/08/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>架构学习的记录</p><a id="more"></a><h3 id="组件化设计"><a href="#组件化设计" class="headerlink" title="组件化设计"></a>组件化设计</h3><p>1.功能模块，互相解耦，通过中间层调用<br>2.公共组件抽离，统一维护管理<br>3.开发人员只做业务</p><p>优点：插件化，业务调整，之间互不影响<br>缺点：公共组件的统一维护可以提高效率，但也存在风险</p><h3 id="极端分离设计"><a href="#极端分离设计" class="headerlink" title="极端分离设计"></a>极端分离设计</h3><p>非专业叫法<br>1.所有模块、及其涉及的通用模块完全独立管理，完全解耦<br>2.模块之间 字典数据传递</p><p>优点：完全的模块分离<br>缺点：开发成本高，适合大型、多开发团队的App</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/09/08/Markdown/"/>
      <url>/2020/09/08/Markdown/</url>
      
        <content type="html"><![CDATA[<p>常用Markdown编辑工具和语法</p><a id="more"></a><h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>网站：<a href="http://typora.io/">http://typora.io</a><br>支持Mac windows</p><h3 id="2-Dillinger"><a href="#2-Dillinger" class="headerlink" title="2.Dillinger"></a>2.Dillinger</h3><p>网站：<a href="http://dillinger.io/">http://dillinger.io</a><br>在线编辑</p><h3 id="3-印象笔记"><a href="#3-印象笔记" class="headerlink" title="3.印象笔记"></a>3.印象笔记</h3><p>支持多平台</p><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><blockquote><p><code># 大标题(注意有空格)</code><br><code>### 次标题 </code><br><code>##### 依次递减</code><br><code>*斜体*</code><br><code>**重点**</code><br><code>- list 列表(支持层级)</code><br><code>&gt; hello 引用样式(支持层级)</code><br><code>-[] checkBox 代办</code><br><code>*** 分隔线</code><br><code>--- 分隔线</code><br><code>|   |   |</code><br><code>|-|-|</code><br><code>|   |   |</code><br>表格(各个工具可能有差异，typora支持的好)<code> </code> <code>  代码块` 两行之间 `</code>c++ 根据语法着色`</p></blockquote><p>更多语法：<br><a href="https://www.jianshu.com/p/b03a8d7b1719">https://www.jianshu.com/p/b03a8d7b1719</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective-oc 笔记(上)</title>
      <link href="/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/08/Effective-oc-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前五章内容：<br>熟悉oc 1-5<br>对象、消息、runtime 6-14<br>接口与API 15-22<br>协议与分类 23-28<br>内存管理 29-36</p><a id="more"></a><h3 id="1-oc起源"><a href="#1-oc起源" class="headerlink" title="1.oc起源"></a>1.oc起源</h3><h3 id="2-减少头文件引用"><a href="#2-减少头文件引用" class="headerlink" title="2.减少头文件引用"></a>2.减少头文件引用</h3><ul><li>如果不使用类方法可以仅声明@class Class 即可</li></ul><h3 id="3-多用字面量"><a href="#3-多用字面量" class="headerlink" title="3.多用字面量"></a>3.多用字面量</h3><ul><li>代码整洁、直观</li><li>NSArray arrayWithObject：遇到nil不会崩溃，内部会判断</li></ul><h3 id="4-少用define"><a href="#4-少用define" class="headerlink" title="4.少用define"></a>4.少用define</h3><ul><li>建议使用const来替代：<ol><li>可以加static 控制作用域、避免冲突</li><li>类型含义明确，维护性好</li><li>static 编译器会自行优化为define</li></ol></li></ul><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><ul><li>占用1字节</li><li>type NS_ENUM oc枚举<ol><li>根据编译平台决定使用新、旧协议(c++)</li><li>新协议指的是底层数据类型存储</li><li>switch 处理enum分支；尽量不用default，覆盖每一个分支，避免新增enum，switch未处理的情况</li></ol></li></ul><h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><ul><li>类对象保管存储偏移量</li><li>@dynamic 配合CoreData动态添加方法</li></ul><h3 id="7-对象内部使用实例变量"><a href="#7-对象内部使用实例变量" class="headerlink" title="7.对象内部使用实例变量"></a>7.对象内部使用实例变量</h3><ul><li><p>self.var 语法</p><ol><li>效率低</li><li>可触发kvo，可使用懒加载</li></ol></li><li><p><code>_var</code> 语法</p><ol><li>不触发kvo</li><li>getter语法里使用</li></ol></li><li><p>折中方案</p><ol><li>写入用setter</li><li>读取用_var</li></ol></li></ul><h3 id="8-对象等同性"><a href="#8-对象等同性" class="headerlink" title="8.对象等同性"></a>8.对象等同性</h3><ul><li>isEqualToString比isEqual快</li><li>== 判断指针操作</li><li>hash()方法用于比较，自己实现；注意set时 的hash 碰撞问题</li><li>结构对象使用主键比较</li></ul><h3 id="9-类簇"><a href="#9-类簇" class="headerlink" title="9.类簇"></a>9.类簇</h3><ul><li>oc没有概念上的抽象类，oc的抽象类不写init</li><li>类簇类似抽象类的概念，提供接口，不提供实现</li><li>NSArray 里面是工厂，NSArray class 隐藏 无法通过实例访问<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[arr <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@|%@&quot;</span>,[str <span class="keyword">class</span>], [<span class="built_in">NSString</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">///分别打印</span></span><br><span class="line">__NSArray0|<span class="built_in">NSArray</span></span><br><span class="line">__NSCFConstantString|<span class="built_in">NSString</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-动态添加属性"><a href="#10-动态添加属性" class="headerlink" title="10.动态添加属性"></a>10.动态添加属性</h3><ul><li>本质是全局创建Map，以Class为key的外部表</li><li>示例：UIAlertView存在多个，通过此方法区分每个；不建议这么用；不好定位异常</li></ul><h3 id="11-消息派发"><a href="#11-消息派发" class="headerlink" title="11.消息派发"></a>11.消息派发</h3><ul><li>objc_msg_send 有两个隐藏参数 (id,SEL)</li><li>runtime</li><li>尾调用优化：去掉函数栈帧，优化</li></ul><h3 id="12-消息转发"><a href="#12-消息转发" class="headerlink" title="12.消息转发"></a>12.消息转发</h3><ul><li>resolveInstanceMethod/resolveClassMethod<ol><li>配合@dynamic</li></ol></li><li>备用接受者 forwardingTargetForSelector<ol><li>返回接收对象</li><li>1对1</li><li>快速</li></ol></li><li>完成消息转发forwardInvocation<ol><li>修改方法内容</li><li>1对多</li><li>慢</li></ol></li></ul><h3 id="13-方法交换"><a href="#13-方法交换" class="headerlink" title="13.方法交换"></a>13.方法交换</h3><ul><li>用于调试目的<ol><li>用户行为监控</li><li>调试异常</li><li>一般应用层不建议使用</li></ol></li></ul><h3 id="14-类对象意义"><a href="#14-类对象意义" class="headerlink" title="14.类对象意义"></a>14.类对象意义</h3><ul><li>判断对象关系 isKindOf isMemberOf；</li><li>示例：NSProxy 对于isKinfOf 对 class处理可能不一样(消息转发)</li><li>消息传递机制的前提</li></ul><h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul><li>c函数需要加前缀</li><li>lib对象，自己引用的第三方加前缀</li></ul><h3 id="16-全能初始化器"><a href="#16-全能初始化器" class="headerlink" title="16.全能初始化器"></a>16.全能初始化器</h3><ul><li><p>和swift的指定初始化器类似，swift 强制性 oc 没有这种约束 designted翻译差异。</p></li><li><p>中文翻译的怪怪的；<br> 我的翻译是：<br> <strong>目标是为了实例的初始化能保证类和其父类的所有成员得到初始化</strong></p><ol><li>全能初始化器的作用是为了保证当前类成员得到初始化</li><li>非全能初始化器应调用当前类全能初始化器</li><li>子类的全能初始化器必须调用父类的全能初始化器</li><li>如果父类的全能初始化器，子类没有实现，那么实例可以直接调用父类的全能初始化器初始化，子类成员变量没有初始化。为了解决这个问题，要么 抛异常，要么 重写父类的全能初始化器</li></ol><p> <strong>这块swift做成了编译检查，而且swift官方文档描述的更清楚</strong></p></li></ul><h3 id="17-实现descripion方法"><a href="#17-实现descripion方法" class="headerlink" title="17.实现descripion方法"></a>17.实现descripion方法</h3><ul><li>自己实现的建议加上类名称和对象地址</li><li>lldb里po 打印的是debugDescripion</li></ul><h3 id="18-使用不可变对象"><a href="#18-使用不可变对象" class="headerlink" title="18.使用不可变对象"></a>18.使用不可变对象</h3><ul><li>涉及到扩展的作用外部ro，内部rw可以点语法修改</li><li>成员变量对外不可变，修改交给类内部</li></ul><h3 id="19-命名方式"><a href="#19-命名方式" class="headerlink" title="19.命名方式"></a>19.命名方式</h3><h3 id="20-为私有方法加前缀"><a href="#20-为私有方法加前缀" class="headerlink" title="20.为私有方法加前缀"></a>20.为私有方法加前缀</h3><ul><li>oc由于动态机制，没有所谓的private函数</li><li>不要用_作为前缀，和苹果自带的冲突</li></ul><h3 id="21-oc错误类型"><a href="#21-oc错误类型" class="headerlink" title="21.oc错误类型"></a>21.oc错误类型</h3><ul><li>使用抽象类建议抛出异常</li><li>NSError** 使用</li></ul><h3 id="22-NSCopying协议"><a href="#22-NSCopying协议" class="headerlink" title="22.NSCopying协议"></a>22.NSCopying协议</h3><ul><li>copy方法调用copyWithZone；注意重写的应是copyWithZone</li></ul><h3 id="23-delegate对象间通信"><a href="#23-delegate对象间通信" class="headerlink" title="23.delegate对象间通信"></a>23.delegate对象间通信</h3><ul><li>delegate属性weak</li><li>自定义代理调用需要判断是否实现方法</li><li>位域代替responseToselector</li></ul><h3 id="24-类拆分成多个分类"><a href="#24-类拆分成多个分类" class="headerlink" title="24.类拆分成多个分类"></a>24.类拆分成多个分类</h3><ul><li>方便管理类</li><li>函数调用栈里可以看到分类信息</li></ul><h3 id="25-分类方法加前缀"><a href="#25-分类方法加前缀" class="headerlink" title="25.分类方法加前缀"></a>25.分类方法加前缀</h3><ul><li>分类加前缀</li><li>分类方法加前缀</li></ul><h3 id="26-分类中不能添加属性"><a href="#26-分类中不能添加属性" class="headerlink" title="26.分类中不能添加属性"></a>26.分类中不能添加属性</h3><ul><li>可以通过同名函数做到模拟属性的效果 不推荐</li><li>关联值添加属性 不推荐<br>感觉翻译的还是有点问题<br>原文：<em>“你可能通过属性特质修改了某个属性的管理语义”</em><br>理解：如果要给一个类批量修改属性@property，一般只记得在主类的头文件修改；如果设置了关联值，很可能忘记修改，维护性差</li></ul><h3 id="27-匿名分类隐藏实现细节"><a href="#27-匿名分类隐藏实现细节" class="headerlink" title="27.匿名分类隐藏实现细节"></a>27.匿名分类隐藏实现细节</h3><ul><li>和c++混编时，c++对象放到匿名分类里，避免重复引用头文件造成</li><li>修改ro属性，内部为rw</li><li>隐藏遵守的协议</li><li>私有属性，没在.h里，一般看不到；私有变量和放在impl里作用相同</li></ul><h3 id="28-协议实现匿名函数"><a href="#28-协议实现匿名函数" class="headerlink" title="28.协议实现匿名函数"></a>28.协议实现匿名函数</h3><ul><li>pop面向协议编程</li><li>隐藏实现，仅暴露协议内容</li></ul><h3 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h3><ul><li>retainCount 不推荐；因为如果autorelease了retainCount值不准确</li><li>mrc return [对象 autorelease],避免调用者不释放</li></ul><h3 id="30-ARC简化引用计数"><a href="#30-ARC简化引用计数" class="headerlink" title="30.ARC简化引用计数"></a>30.ARC简化引用计数</h3><ul><li>autorelease 后的返回函数 接收强类型对象 编译会自动retain</li><li>不能复写release函数</li><li>CF对象自行释放</li></ul><h3 id="31-dealloc作用"><a href="#31-dealloc作用" class="headerlink" title="31.dealloc作用"></a>31.dealloc作用</h3><ul><li>不要调用存取方法</li><li>可能并不会触发、在应用异常退出；可以在ApplicationWillTerminate里释放</li><li>某些文件句柄、socket系统映射文件，不要直接释放、调用相应close方法</li><li>释放c对象</li><li>释放通知、kvo</li><li></li></ul><h3 id="32-捕获异常"><a href="#32-捕获异常" class="headerlink" title="32.捕获异常"></a>32.捕获异常</h3><ul><li>arc 下不建议 try catch ，加很多辅助代码</li><li>如果objc++ 可以处理try catch</li></ul><h3 id="33-弱引用避免循环引用"><a href="#33-弱引用避免循环引用" class="headerlink" title="33.弱引用避免循环引用"></a>33.弱引用避免循环引用</h3><ul><li>weak属性 避免出现引用闭环</li></ul><h3 id="34-自动释放块"><a href="#34-自动释放块" class="headerlink" title="34.自动释放块"></a>34.自动释放块</h3><ul><li>可以在循环中创建对象使用，控制内存</li></ul><h3 id="35-僵尸对象调试"><a href="#35-僵尸对象调试" class="headerlink" title="35.僵尸对象调试"></a>35.僵尸对象调试</h3><ul><li>打开编译开关</li><li>原理：生成僵尸子类，由僵尸子类处理消息</li></ul><h3 id="36-retainCount"><a href="#36-retainCount" class="headerlink" title="36.retainCount"></a>36.retainCount</h3><ul><li>不建议用</li><li>由于autorelease，某一个时刻不代表真实值</li><li>优化原因，可能永远不为0</li><li>常量区对象也会有retainCount值，int.max</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oc </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tranquilpeak主题配置</title>
      <link href="/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/08/07/Tranquilpeak%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>hexo Tranquilpeak 主题配置</p><a id="more"></a><p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md#installation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高开发效率的N种方法</title>
      <link href="/2020/08/07/iOS/"/>
      <url>/2020/08/07/iOS/</url>
      
        <content type="html"><![CDATA[<p>介绍几种提高mac下开发效率的方法、包括Xcode快捷键、vi快捷键、Alfred工作流、宏</p><a id="more"></a> <h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><pre><code>ctrl+f                光标向前ctrl+b                光标向后ctrl+a                光标行头ctrl+e                光标行尾ctrl+shift+f          向前选中ctrl+shift+b          向后选中ctrl+shift+a          向前选中至行头ctrl+shift+e          向后选中至行尾ctrl+k                向后删除当前行ctrl+6                搜索当前文件函数ctril+shift+,         显示scheme配置（build、run等）cmd+,                 配置工程ctrl+cmd+up/down      头文件和实现文件切换ctrl+cmd+left/right   文件历史栈切换</code></pre><h3 id="vi快捷键"><a href="#vi快捷键" class="headerlink" title="vi快捷键"></a>vi快捷键</h3><pre><code>shift zz 快速保存退出</code></pre><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>#<div class="video-container"><iframe src="https://www.youtube.com/embed/DBWu6TnhLeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> xcode </tag>
            
            <tag> 效率 </tag>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
